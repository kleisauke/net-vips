//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     libvips version: 8.17.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.IO;

namespace NetVips;

public partial class Image
{
    #region auto-generated functions

    /// <summary>
    /// Absolute value of an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Abs();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Abs()
    {
        return this.Call("abs") as Image;
    }

    /// <summary>
    /// Add two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Add(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Add(Image right)
    {
        return this.Call("add", right) as Image;
    }

    /// <summary>
    /// Affine transform of an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Affine(matrix, interpolate: GObject, oarea: int[], odx: double, ody: double, idx: double, idy: double, background: double[], premultiplied: bool, extend: Enums.Extend);
    /// </code>
    /// </example>
    /// <param name="matrix">Transformation matrix.</param>
    /// <param name="interpolate">Interpolate pixels with this.</param>
    /// <param name="oarea">Area of output to generate.</param>
    /// <param name="odx">Horizontal output displacement.</param>
    /// <param name="ody">Vertical output displacement.</param>
    /// <param name="idx">Horizontal input displacement.</param>
    /// <param name="idy">Vertical input displacement.</param>
    /// <param name="background">Background value.</param>
    /// <param name="premultiplied">Images have premultiplied alpha.</param>
    /// <param name="extend">How to generate the extra pixels.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Affine(double[] matrix, GObject interpolate = null, int[] oarea = null, double? odx = null, double? ody = null, double? idx = null, double? idy = null, double[] background = null, bool? premultiplied = null, Enums.Extend? extend = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interpolate), interpolate);
        options.AddIfPresent(nameof(oarea), oarea);
        options.AddIfPresent(nameof(odx), odx);
        options.AddIfPresent(nameof(ody), ody);
        options.AddIfPresent(nameof(idx), idx);
        options.AddIfPresent(nameof(idy), idy);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(premultiplied), premultiplied);
        options.AddIfPresent(nameof(extend), extend);

        return this.Call("affine", options, matrix) as Image;
    }

    /// <summary>
    /// Load an Analyze6 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Analyzeload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Analyzeload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("analyzeload", options, filename) as Image;
    }

    /// <summary>
    /// Load an Analyze6 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Analyzeload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Analyzeload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("analyzeload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Join an array of images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Arrayjoin(@in, across: int, shim: int, background: double[], halign: Enums.Align, valign: Enums.Align, hspacing: int, vspacing: int);
    /// </code>
    /// </example>
    /// <param name="in">Array of input images.</param>
    /// <param name="across">Number of images across grid.</param>
    /// <param name="shim">Pixels between images.</param>
    /// <param name="background">Colour for new pixels.</param>
    /// <param name="halign">Align on the left, centre or right.</param>
    /// <param name="valign">Align on the top, centre or bottom.</param>
    /// <param name="hspacing">Horizontal spacing between images.</param>
    /// <param name="vspacing">Vertical spacing between images.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Arrayjoin(Image[] @in, int? across = null, int? shim = null, double[] background = null, Enums.Align? halign = null, Enums.Align? valign = null, int? hspacing = null, int? vspacing = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(across), across);
        options.AddIfPresent(nameof(shim), shim);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(halign), halign);
        options.AddIfPresent(nameof(valign), valign);
        options.AddIfPresent(nameof(hspacing), hspacing);
        options.AddIfPresent(nameof(vspacing), vspacing);

        return Operation.Call("arrayjoin", options, new object[] { @in }) as Image;
    }

    /// <summary>
    /// Autorotate image by exif tag.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Autorot();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Autorot()
    {
        return this.Call("autorot") as Image;
    }

    /// <summary>
    /// Autorotate image by exif tag.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Autorot(out var angle);
    /// </code>
    /// </example>
    /// <param name="angle">Angle image was rotated by.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Autorot(out Enums.Angle angle)
    {
        var optionalOutput = new VOption
        {
            {"angle", true}
        };

        var results = this.Call("autorot", optionalOutput) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        angle = (Enums.Angle)opts?["angle"];

        return finalResult;
    }

    /// <summary>
    /// Autorotate image by exif tag.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Autorot(out var angle, out var flip);
    /// </code>
    /// </example>
    /// <param name="angle">Angle image was rotated by.</param>
    /// <param name="flip">Whether the image was flipped or not.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Autorot(out Enums.Angle angle, out bool flip)
    {
        var optionalOutput = new VOption
        {
            {"angle", true},
            {"flip", true}
        };

        var results = this.Call("autorot", optionalOutput) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        angle = (Enums.Angle)opts?["angle"];
        flip = opts?["flip"] is bool out2 && out2;

        return finalResult;
    }

    /// <summary>
    /// Find image average.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Avg();
    /// </code>
    /// </example>
    /// <returns>A double.</returns>
    public double Avg()
    {
        return this.Call("avg") is double result ? result : 0d;
    }

    /// <summary>
    /// Boolean operation across image bands.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Bandbool(boolean);
    /// </code>
    /// </example>
    /// <param name="boolean">Boolean to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Bandbool(Enums.OperationBoolean boolean)
    {
        return this.Call("bandbool", boolean) as Image;
    }

    /// <summary>
    /// Fold up x axis into bands.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Bandfold(factor: int);
    /// </code>
    /// </example>
    /// <param name="factor">Fold by this factor.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Bandfold(int? factor = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(factor), factor);

        return this.Call("bandfold", options) as Image;
    }

    /// <summary>
    /// Append a constant band to an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.BandjoinConst(c);
    /// </code>
    /// </example>
    /// <param name="c">Array of constants to add.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image BandjoinConst(double[] c)
    {
        return this.Call("bandjoin_const", c) as Image;
    }

    /// <summary>
    /// Band-wise average.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Bandmean();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Bandmean()
    {
        return this.Call("bandmean") as Image;
    }

    /// <summary>
    /// Unfold image bands into x axis.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Bandunfold(factor: int);
    /// </code>
    /// </example>
    /// <param name="factor">Unfold by this factor.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Bandunfold(int? factor = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(factor), factor);

        return this.Call("bandunfold", options) as Image;
    }

    /// <summary>
    /// Make a black image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Black(width, height, bands: int);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="bands">Number of bands in image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Black(int width, int height, int? bands = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(bands), bands);

        return Operation.Call("black", options, width, height) as Image;
    }

    /// <summary>
    /// Boolean operation on two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Boolean(right, boolean);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <param name="boolean">Boolean to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Boolean(Image right, Enums.OperationBoolean boolean)
    {
        return this.Call("boolean", right, boolean) as Image;
    }

    /// <summary>
    /// Boolean operations against a constant.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.BooleanConst(boolean, c);
    /// </code>
    /// </example>
    /// <param name="boolean">Boolean to perform.</param>
    /// <param name="c">Array of constants.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image BooleanConst(Enums.OperationBoolean boolean, double[] c)
    {
        return this.Call("boolean_const", boolean, c) as Image;
    }

    /// <summary>
    /// Build a look-up table.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Buildlut();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Buildlut()
    {
        return this.Call("buildlut") as Image;
    }

    /// <summary>
    /// Byteswap an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Byteswap();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Byteswap()
    {
        return this.Call("byteswap") as Image;
    }

    /// <summary>
    /// Canny edge detector.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Canny(sigma: double, precision: Enums.Precision);
    /// </code>
    /// </example>
    /// <param name="sigma">Sigma of Gaussian.</param>
    /// <param name="precision">Convolve with this precision.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Canny(double? sigma = null, Enums.Precision? precision = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(sigma), sigma);
        options.AddIfPresent(nameof(precision), precision);

        return this.Call("canny", options) as Image;
    }

    /// <summary>
    /// Cast an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Cast(format, shift: bool);
    /// </code>
    /// </example>
    /// <param name="format">Format to cast to.</param>
    /// <param name="shift">Shift integer values up and down.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Cast(Enums.BandFormat format, bool? shift = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shift), shift);

        return this.Call("cast", options, format) as Image;
    }

    /// <summary>
    /// Clamp values of an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Clamp(min: double, max: double);
    /// </code>
    /// </example>
    /// <param name="min">Minimum value.</param>
    /// <param name="max">Maximum value.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Clamp(double? min = null, double? max = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(min), min);
        options.AddIfPresent(nameof(max), max);

        return this.Call("clamp", options) as Image;
    }

    /// <summary>
    /// Transform LCh to CMC.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.CMC2LCh();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image CMC2LCh()
    {
        return this.Call("CMC2LCh") as Image;
    }

    /// <summary>
    /// Transform CMYK to XYZ.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.CMYK2XYZ();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image CMYK2XYZ()
    {
        return this.Call("CMYK2XYZ") as Image;
    }

    /// <summary>
    /// Convert to a new colorspace.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Colourspace(space, sourceSpace: Enums.Interpretation);
    /// </code>
    /// </example>
    /// <param name="space">Destination color space.</param>
    /// <param name="sourceSpace">Source color space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Colourspace(Enums.Interpretation space, Enums.Interpretation? sourceSpace = null)
    {
        var options = new VOption();

        options.AddIfPresent("source_space", sourceSpace);

        return this.Call("colourspace", options, space) as Image;
    }

    /// <summary>
    /// Convolve with rotating mask.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Compass(mask, times: int, angle: Enums.Angle45, combine: Enums.Combine, precision: Enums.Precision, layers: int, cluster: int);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <param name="times">Rotate and convolve this many times.</param>
    /// <param name="angle">Rotate mask by this much between convolutions.</param>
    /// <param name="combine">Combine convolution results like this.</param>
    /// <param name="precision">Convolve with this precision.</param>
    /// <param name="layers">Use this many layers in approximation.</param>
    /// <param name="cluster">Cluster lines closer than this in approximation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Compass(Image mask, int? times = null, Enums.Angle45? angle = null, Enums.Combine? combine = null, Enums.Precision? precision = null, int? layers = null, int? cluster = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(times), times);
        options.AddIfPresent(nameof(angle), angle);
        options.AddIfPresent(nameof(combine), combine);
        options.AddIfPresent(nameof(precision), precision);
        options.AddIfPresent(nameof(layers), layers);
        options.AddIfPresent(nameof(cluster), cluster);

        return this.Call("compass", options, mask) as Image;
    }

    /// <summary>
    /// Perform a complex operation on an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Complex(cmplx);
    /// </code>
    /// </example>
    /// <param name="cmplx">Complex to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Complex(Enums.OperationComplex cmplx)
    {
        return this.Call("complex", cmplx) as Image;
    }

    /// <summary>
    /// Complex binary operations on two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Complex2(right, cmplx);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <param name="cmplx">Binary complex operation to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Complex2(Image right, Enums.OperationComplex2 cmplx)
    {
        return this.Call("complex2", right, cmplx) as Image;
    }

    /// <summary>
    /// Form a complex image from two real images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Complexform(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Complexform(Image right)
    {
        return this.Call("complexform", right) as Image;
    }

    /// <summary>
    /// Get a component from a complex image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Complexget(get);
    /// </code>
    /// </example>
    /// <param name="get">Complex to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Complexget(Enums.OperationComplexget get)
    {
        return this.Call("complexget", get) as Image;
    }

    /// <summary>
    /// Blend a pair of images with a blend mode.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = base.Composite2(overlay, mode, x: int, y: int, compositingSpace: Enums.Interpretation, premultiplied: bool);
    /// </code>
    /// </example>
    /// <param name="overlay">Overlay image.</param>
    /// <param name="mode">VipsBlendMode to join with.</param>
    /// <param name="x">x position of overlay.</param>
    /// <param name="y">y position of overlay.</param>
    /// <param name="compositingSpace">Composite images in this colour space.</param>
    /// <param name="premultiplied">Images have premultiplied alpha.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Composite2(Image overlay, Enums.BlendMode mode, int? x = null, int? y = null, Enums.Interpretation? compositingSpace = null, bool? premultiplied = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(x), x);
        options.AddIfPresent(nameof(y), y);
        options.AddIfPresent("compositing_space", compositingSpace);
        options.AddIfPresent(nameof(premultiplied), premultiplied);

        return this.Call("composite2", options, overlay, mode) as Image;
    }

    /// <summary>
    /// Convolution operation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Conv(mask, precision: Enums.Precision, layers: int, cluster: int);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <param name="precision">Convolve with this precision.</param>
    /// <param name="layers">Use this many layers in approximation.</param>
    /// <param name="cluster">Cluster lines closer than this in approximation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Conv(Image mask, Enums.Precision? precision = null, int? layers = null, int? cluster = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(precision), precision);
        options.AddIfPresent(nameof(layers), layers);
        options.AddIfPresent(nameof(cluster), cluster);

        return this.Call("conv", options, mask) as Image;
    }

    /// <summary>
    /// Approximate integer convolution.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Conva(mask, layers: int, cluster: int);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <param name="layers">Use this many layers in approximation.</param>
    /// <param name="cluster">Cluster lines closer than this in approximation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Conva(Image mask, int? layers = null, int? cluster = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(layers), layers);
        options.AddIfPresent(nameof(cluster), cluster);

        return this.Call("conva", options, mask) as Image;
    }

    /// <summary>
    /// Approximate separable integer convolution.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Convasep(mask, layers: int);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <param name="layers">Use this many layers in approximation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Convasep(Image mask, int? layers = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(layers), layers);

        return this.Call("convasep", options, mask) as Image;
    }

    /// <summary>
    /// Float convolution operation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Convf(mask);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Convf(Image mask)
    {
        return this.Call("convf", mask) as Image;
    }

    /// <summary>
    /// Int convolution operation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Convi(mask);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Convi(Image mask)
    {
        return this.Call("convi", mask) as Image;
    }

    /// <summary>
    /// Separable convolution operation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Convsep(mask, precision: Enums.Precision, layers: int, cluster: int);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <param name="precision">Convolve with this precision.</param>
    /// <param name="layers">Use this many layers in approximation.</param>
    /// <param name="cluster">Cluster lines closer than this in approximation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Convsep(Image mask, Enums.Precision? precision = null, int? layers = null, int? cluster = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(precision), precision);
        options.AddIfPresent(nameof(layers), layers);
        options.AddIfPresent(nameof(cluster), cluster);

        return this.Call("convsep", options, mask) as Image;
    }

    /// <summary>
    /// Copy an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Copy(width: int, height: int, bands: int, format: Enums.BandFormat, coding: Enums.Coding, interpretation: Enums.Interpretation, xres: double, yres: double, xoffset: int, yoffset: int);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="bands">Number of bands in image.</param>
    /// <param name="format">Pixel format in image.</param>
    /// <param name="coding">Pixel coding.</param>
    /// <param name="interpretation">Pixel interpretation.</param>
    /// <param name="xres">Horizontal resolution in pixels/mm.</param>
    /// <param name="yres">Vertical resolution in pixels/mm.</param>
    /// <param name="xoffset">Horizontal offset of origin.</param>
    /// <param name="yoffset">Vertical offset of origin.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Copy(int? width = null, int? height = null, int? bands = null, Enums.BandFormat? format = null, Enums.Coding? coding = null, Enums.Interpretation? interpretation = null, double? xres = null, double? yres = null, int? xoffset = null, int? yoffset = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(width), width);
        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(bands), bands);
        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(coding), coding);
        options.AddIfPresent(nameof(interpretation), interpretation);
        options.AddIfPresent(nameof(xres), xres);
        options.AddIfPresent(nameof(yres), yres);
        options.AddIfPresent(nameof(xoffset), xoffset);
        options.AddIfPresent(nameof(yoffset), yoffset);

        return this.Call("copy", options) as Image;
    }

    /// <summary>
    /// Count lines in an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double nolines = in.Countlines(direction);
    /// </code>
    /// </example>
    /// <param name="direction">Countlines left-right or up-down.</param>
    /// <returns>A double.</returns>
    public double Countlines(Enums.Direction direction)
    {
        return this.Call("countlines", direction) is double result ? result : 0d;
    }

    /// <summary>
    /// Load csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Csvload(filename, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="skip">Skip this many lines at the start of the file.</param>
    /// <param name="lines">Read this many lines from the file.</param>
    /// <param name="whitespace">Set of whitespace characters.</param>
    /// <param name="separator">Set of separator characters.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Csvload(string filename, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(skip), skip);
        options.AddIfPresent(nameof(lines), lines);
        options.AddIfPresent(nameof(whitespace), whitespace);
        options.AddIfPresent(nameof(separator), separator);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("csvload", options, filename) as Image;
    }

    /// <summary>
    /// Load csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Csvload(filename, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="skip">Skip this many lines at the start of the file.</param>
    /// <param name="lines">Read this many lines from the file.</param>
    /// <param name="whitespace">Set of whitespace characters.</param>
    /// <param name="separator">Set of separator characters.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Csvload(string filename, out Enums.ForeignFlags flags, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(skip), skip);
        options.AddIfPresent(nameof(lines), lines);
        options.AddIfPresent(nameof(whitespace), whitespace);
        options.AddIfPresent(nameof(separator), separator);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("csvload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.CsvloadSource(source, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="skip">Skip this many lines at the start of the file.</param>
    /// <param name="lines">Read this many lines from the file.</param>
    /// <param name="whitespace">Set of whitespace characters.</param>
    /// <param name="separator">Set of separator characters.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image CsvloadSource(Source source, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(skip), skip);
        options.AddIfPresent(nameof(lines), lines);
        options.AddIfPresent(nameof(whitespace), whitespace);
        options.AddIfPresent(nameof(separator), separator);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("csvload_source", options, source) as Image;
    }

    /// <summary>
    /// Load csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.CsvloadStream(stream, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="skip">Skip this many lines at the start of the file.</param>
    /// <param name="lines">Read this many lines from the file.</param>
    /// <param name="whitespace">Set of whitespace characters.</param>
    /// <param name="separator">Set of separator characters.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image CsvloadStream(Stream stream, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = CsvloadSource(source, skip, lines, whitespace, separator, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.CsvloadSource(source, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="skip">Skip this many lines at the start of the file.</param>
    /// <param name="lines">Read this many lines from the file.</param>
    /// <param name="whitespace">Set of whitespace characters.</param>
    /// <param name="separator">Set of separator characters.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image CsvloadSource(Source source, out Enums.ForeignFlags flags, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(skip), skip);
        options.AddIfPresent(nameof(lines), lines);
        options.AddIfPresent(nameof(whitespace), whitespace);
        options.AddIfPresent(nameof(separator), separator);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("csvload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.CsvloadStream(stream, out var flags, skip: int, lines: int, whitespace: string, separator: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="skip">Skip this many lines at the start of the file.</param>
    /// <param name="lines">Read this many lines from the file.</param>
    /// <param name="whitespace">Set of whitespace characters.</param>
    /// <param name="separator">Set of separator characters.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image CsvloadStream(Stream stream, out Enums.ForeignFlags flags, int? skip = null, int? lines = null, string whitespace = null, string separator = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = CsvloadSource(source, out flags, skip, lines, whitespace, separator, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Csvsave(filename, separator: string, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="separator">Separator characters.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Csvsave(string filename, string separator = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(separator), separator);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("csvsave", options, filename);
    }

    /// <summary>
    /// Save image to csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.CsvsaveTarget(target, separator: string, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="separator">Separator characters.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void CsvsaveTarget(Target target, string separator = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(separator), separator);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("csvsave_target", options, target);
    }

    /// <summary>
    /// Save image to csv.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.CsvsaveStream(stream, separator: string, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="separator">Separator characters.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void CsvsaveStream(Stream stream, string separator = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        CsvsaveTarget(target, separator, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Calculate dE00.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.DE00(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand input image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image DE00(Image right)
    {
        return this.Call("dE00", right) as Image;
    }

    /// <summary>
    /// Calculate dE76.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.DE76(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand input image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image DE76(Image right)
    {
        return this.Call("dE76", right) as Image;
    }

    /// <summary>
    /// Calculate dECMC.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.DECMC(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand input image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image DECMC(Image right)
    {
        return this.Call("dECMC", right) as Image;
    }

    /// <summary>
    /// Find image standard deviation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Deviate();
    /// </code>
    /// </example>
    /// <returns>A double.</returns>
    public double Deviate()
    {
        return this.Call("deviate") is double result ? result : 0d;
    }

    /// <summary>
    /// Divide two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Divide(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Divide(Image right)
    {
        return this.Call("divide", right) as Image;
    }

    /// <summary>
    /// Save image to deepzoom file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Dzsave(filename, imagename: string, layout: Enums.ForeignDzLayout, suffix: string, overlap: int, tileSize: int, centre: bool, depth: Enums.ForeignDzDepth, angle: Enums.Angle, container: Enums.ForeignDzContainer, compression: int, regionShrink: Enums.RegionShrink, skipBlanks: int, id: string, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="imagename">Image name.</param>
    /// <param name="layout">Directory layout.</param>
    /// <param name="suffix">Filename suffix for tiles.</param>
    /// <param name="overlap">Tile overlap in pixels.</param>
    /// <param name="tileSize">Tile size in pixels.</param>
    /// <param name="centre">Center image in tile.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="angle">Rotate image during save.</param>
    /// <param name="container">Pyramid container type.</param>
    /// <param name="compression">ZIP deflate compression level.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
    /// <param name="id">Resource ID.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Dzsave(string filename, string imagename = null, Enums.ForeignDzLayout? layout = null, string suffix = null, int? overlap = null, int? tileSize = null, bool? centre = null, Enums.ForeignDzDepth? depth = null, Enums.Angle? angle = null, Enums.ForeignDzContainer? container = null, int? compression = null, Enums.RegionShrink? regionShrink = null, int? skipBlanks = null, string id = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(NetVips.AtLeastLibvips(8, 15) ? nameof(imagename) : "basename", imagename);
        options.AddIfPresent(nameof(layout), layout);
        options.AddIfPresent(nameof(suffix), suffix);
        options.AddIfPresent(nameof(overlap), overlap);
        options.AddIfPresent("tile_size", tileSize);
        options.AddIfPresent(nameof(centre), centre);
        options.AddIfPresent(nameof(depth), depth);
        options.AddIfPresent(nameof(angle), angle);
        options.AddIfPresent(nameof(container), container);
        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent("region_shrink", regionShrink);
        options.AddIfPresent("skip_blanks", skipBlanks);
        options.AddIfPresent(nameof(id), id);
        options.AddIfPresent("Q", q);
        options.AddForeignKeep(keep, true);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("dzsave", options, filename);
    }

    /// <summary>
    /// Save image to dz buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.DzsaveBuffer(imagename: string, layout: Enums.ForeignDzLayout, suffix: string, overlap: int, tileSize: int, centre: bool, depth: Enums.ForeignDzDepth, angle: Enums.Angle, container: Enums.ForeignDzContainer, compression: int, regionShrink: Enums.RegionShrink, skipBlanks: int, id: string, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="imagename">Image name.</param>
    /// <param name="layout">Directory layout.</param>
    /// <param name="suffix">Filename suffix for tiles.</param>
    /// <param name="overlap">Tile overlap in pixels.</param>
    /// <param name="tileSize">Tile size in pixels.</param>
    /// <param name="centre">Center image in tile.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="angle">Rotate image during save.</param>
    /// <param name="container">Pyramid container type.</param>
    /// <param name="compression">ZIP deflate compression level.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
    /// <param name="id">Resource ID.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] DzsaveBuffer(string imagename = null, Enums.ForeignDzLayout? layout = null, string suffix = null, int? overlap = null, int? tileSize = null, bool? centre = null, Enums.ForeignDzDepth? depth = null, Enums.Angle? angle = null, Enums.ForeignDzContainer? container = null, int? compression = null, Enums.RegionShrink? regionShrink = null, int? skipBlanks = null, string id = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(NetVips.AtLeastLibvips(8, 15) ? nameof(imagename) : "basename", imagename);
        options.AddIfPresent(nameof(layout), layout);
        options.AddIfPresent(nameof(suffix), suffix);
        options.AddIfPresent(nameof(overlap), overlap);
        options.AddIfPresent("tile_size", tileSize);
        options.AddIfPresent(nameof(centre), centre);
        options.AddIfPresent(nameof(depth), depth);
        options.AddIfPresent(nameof(angle), angle);
        options.AddIfPresent(nameof(container), container);
        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent("region_shrink", regionShrink);
        options.AddIfPresent("skip_blanks", skipBlanks);
        options.AddIfPresent(nameof(id), id);
        options.AddIfPresent("Q", q);
        options.AddForeignKeep(keep, true);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("dzsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image to deepzoom target.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.DzsaveTarget(target, imagename: string, layout: Enums.ForeignDzLayout, suffix: string, overlap: int, tileSize: int, centre: bool, depth: Enums.ForeignDzDepth, angle: Enums.Angle, container: Enums.ForeignDzContainer, compression: int, regionShrink: Enums.RegionShrink, skipBlanks: int, id: string, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="imagename">Image name.</param>
    /// <param name="layout">Directory layout.</param>
    /// <param name="suffix">Filename suffix for tiles.</param>
    /// <param name="overlap">Tile overlap in pixels.</param>
    /// <param name="tileSize">Tile size in pixels.</param>
    /// <param name="centre">Center image in tile.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="angle">Rotate image during save.</param>
    /// <param name="container">Pyramid container type.</param>
    /// <param name="compression">ZIP deflate compression level.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
    /// <param name="id">Resource ID.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void DzsaveTarget(Target target, string imagename = null, Enums.ForeignDzLayout? layout = null, string suffix = null, int? overlap = null, int? tileSize = null, bool? centre = null, Enums.ForeignDzDepth? depth = null, Enums.Angle? angle = null, Enums.ForeignDzContainer? container = null, int? compression = null, Enums.RegionShrink? regionShrink = null, int? skipBlanks = null, string id = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(NetVips.AtLeastLibvips(8, 15) ? nameof(imagename) : "basename", imagename);
        options.AddIfPresent(nameof(layout), layout);
        options.AddIfPresent(nameof(suffix), suffix);
        options.AddIfPresent(nameof(overlap), overlap);
        options.AddIfPresent("tile_size", tileSize);
        options.AddIfPresent(nameof(centre), centre);
        options.AddIfPresent(nameof(depth), depth);
        options.AddIfPresent(nameof(angle), angle);
        options.AddIfPresent(nameof(container), container);
        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent("region_shrink", regionShrink);
        options.AddIfPresent("skip_blanks", skipBlanks);
        options.AddIfPresent(nameof(id), id);
        options.AddIfPresent("Q", q);
        options.AddForeignKeep(keep, true);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("dzsave_target", options, target);
    }

    /// <summary>
    /// Save image to deepzoom stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.DzsaveStream(stream, imagename: string, layout: Enums.ForeignDzLayout, suffix: string, overlap: int, tileSize: int, centre: bool, depth: Enums.ForeignDzDepth, angle: Enums.Angle, container: Enums.ForeignDzContainer, compression: int, regionShrink: Enums.RegionShrink, skipBlanks: int, id: string, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="imagename">Image name.</param>
    /// <param name="layout">Directory layout.</param>
    /// <param name="suffix">Filename suffix for tiles.</param>
    /// <param name="overlap">Tile overlap in pixels.</param>
    /// <param name="tileSize">Tile size in pixels.</param>
    /// <param name="centre">Center image in tile.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="angle">Rotate image during save.</param>
    /// <param name="container">Pyramid container type.</param>
    /// <param name="compression">ZIP deflate compression level.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="skipBlanks">Skip tiles which are nearly equal to the background.</param>
    /// <param name="id">Resource ID.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void DzsaveStream(Stream stream, string imagename = null, Enums.ForeignDzLayout? layout = null, string suffix = null, int? overlap = null, int? tileSize = null, bool? centre = null, Enums.ForeignDzDepth? depth = null, Enums.Angle? angle = null, Enums.ForeignDzContainer? container = null, int? compression = null, Enums.RegionShrink? regionShrink = null, int? skipBlanks = null, string id = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        DzsaveTarget(target, imagename, layout, suffix, overlap, tileSize, centre, depth, angle, container, compression, regionShrink, skipBlanks, id, q, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Embed an image in a larger image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Embed(x, y, width, height, extend: Enums.Extend, background: double[]);
    /// </code>
    /// </example>
    /// <param name="x">Left edge of input in output.</param>
    /// <param name="y">Top edge of input in output.</param>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="extend">How to generate the extra pixels.</param>
    /// <param name="background">Color for background pixels.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Embed(int x, int y, int width, int height, Enums.Extend? extend = null, double[] background = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(extend), extend);
        options.AddIfPresent(nameof(background), background);

        return this.Call("embed", options, x, y, width, height) as Image;
    }

    /// <summary>
    /// Extract an area from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = input.ExtractArea(left, top, width, height);
    /// </code>
    /// </example>
    /// <param name="left">Left edge of extract area.</param>
    /// <param name="top">Top edge of extract area.</param>
    /// <param name="width">Width of extract area.</param>
    /// <param name="height">Height of extract area.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image ExtractArea(int left, int top, int width, int height)
    {
        return this.Call("extract_area", left, top, width, height) as Image;
    }

    /// <summary>
    /// Extract band from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.ExtractBand(band, n: int);
    /// </code>
    /// </example>
    /// <param name="band">Band to extract.</param>
    /// <param name="n">Number of bands to extract.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image ExtractBand(int band, int? n = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);

        return this.Call("extract_band", options, band) as Image;
    }

    /// <summary>
    /// Make an image showing the eye's spatial response.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Eye(width, height, uchar: bool, factor: double);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="factor">Maximum spatial frequency.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Eye(int width, int height, bool? uchar = null, double? factor = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(factor), factor);

        return Operation.Call("eye", options, width, height) as Image;
    }

    /// <summary>
    /// False-color an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Falsecolour();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Falsecolour()
    {
        return this.Call("falsecolour") as Image;
    }

    /// <summary>
    /// Fast correlation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Fastcor(@ref);
    /// </code>
    /// </example>
    /// <param name="ref">Input reference image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Fastcor(Image @ref)
    {
        return this.Call("fastcor", @ref) as Image;
    }

    /// <summary>
    /// Fill image zeros with nearest non-zero pixel.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.FillNearest();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image FillNearest()
    {
        return this.Call("fill_nearest") as Image;
    }

    /// <summary>
    /// Fill image zeros with nearest non-zero pixel.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.FillNearest(out var distance);
    /// </code>
    /// </example>
    /// <param name="distance">Distance to nearest non-zero pixel.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image FillNearest(out Image distance)
    {
        var optionalOutput = new VOption
        {
            {"distance", true}
        };

        var results = this.Call("fill_nearest", optionalOutput) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        distance = opts?["distance"] as Image;

        return finalResult;
    }

    /// <summary>
    /// Search an image for non-edge areas.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// var output = in.FindTrim(threshold: double, background: double[], lineArt: bool);
    /// </code>
    /// </example>
    /// <param name="threshold">Object threshold.</param>
    /// <param name="background">Color for background pixels.</param>
    /// <param name="lineArt">Enable line art mode.</param>
    /// <returns>An array of objects.</returns>
    public object[] FindTrim(double? threshold = null, double[] background = null, bool? lineArt = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(threshold), threshold);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("line_art", lineArt);

        return this.Call("find_trim", options) as object[];
    }

    /// <summary>
    /// Load a FITS image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Fitsload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Fitsload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("fitsload", options, filename) as Image;
    }

    /// <summary>
    /// Load a FITS image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Fitsload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Fitsload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("fitsload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load FITS from a source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.FitsloadSource(source, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image FitsloadSource(Source source, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("fitsload_source", options, source) as Image;
    }

    /// <summary>
    /// Load FITS from a stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.FitsloadStream(stream, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image FitsloadStream(Stream stream, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = FitsloadSource(source, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load FITS from a source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.FitsloadSource(source, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image FitsloadSource(Source source, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("fitsload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load FITS from a stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.FitsloadStream(stream, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image FitsloadStream(Stream stream, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = FitsloadSource(source, out flags, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to fits file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Fitssave(filename, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Fitssave(string filename, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("fitssave", options, filename);
    }

    /// <summary>
    /// Flatten alpha out of an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Flatten(background: double[], maxAlpha: double);
    /// </code>
    /// </example>
    /// <param name="background">Background value.</param>
    /// <param name="maxAlpha">Maximum value of alpha channel.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Flatten(double[] background = null, double? maxAlpha = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("max_alpha", maxAlpha);

        return this.Call("flatten", options) as Image;
    }

    /// <summary>
    /// Flip an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Flip(direction);
    /// </code>
    /// </example>
    /// <param name="direction">Direction to flip image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Flip(Enums.Direction direction)
    {
        return this.Call("flip", direction) as Image;
    }

    /// <summary>
    /// Transform float RGB to Radiance coding.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Float2rad();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Float2rad()
    {
        return this.Call("float2rad") as Image;
    }

    /// <summary>
    /// Make a fractal surface.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Fractsurf(width, height, fractalDimension);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="fractalDimension">Fractal dimension.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Fractsurf(int width, int height, double fractalDimension)
    {
        return Operation.Call("fractsurf", width, height, fractalDimension) as Image;
    }

    /// <summary>
    /// Frequency-domain filtering.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Freqmult(mask);
    /// </code>
    /// </example>
    /// <param name="mask">Input mask image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Freqmult(Image mask)
    {
        return this.Call("freqmult", mask) as Image;
    }

    /// <summary>
    /// Forward FFT.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Fwfft();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Fwfft()
    {
        return this.Call("fwfft") as Image;
    }

    /// <summary>
    /// Gamma an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Gamma(exponent: double);
    /// </code>
    /// </example>
    /// <param name="exponent">Gamma factor.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Gamma(double? exponent = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(exponent), exponent);

        return this.Call("gamma", options) as Image;
    }

    /// <summary>
    /// Gaussian blur.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Gaussblur(sigma, minAmpl: double, precision: Enums.Precision);
    /// </code>
    /// </example>
    /// <param name="sigma">Sigma of Gaussian.</param>
    /// <param name="minAmpl">Minimum amplitude of Gaussian.</param>
    /// <param name="precision">Convolve with this precision.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Gaussblur(double sigma, double? minAmpl = null, Enums.Precision? precision = null)
    {
        var options = new VOption();

        options.AddIfPresent("min_ampl", minAmpl);
        options.AddIfPresent(nameof(precision), precision);

        return this.Call("gaussblur", options, sigma) as Image;
    }

    /// <summary>
    /// Make a gaussian image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Gaussmat(sigma, minAmpl, separable: bool, precision: Enums.Precision);
    /// </code>
    /// </example>
    /// <param name="sigma">Sigma of Gaussian.</param>
    /// <param name="minAmpl">Minimum amplitude of Gaussian.</param>
    /// <param name="separable">Generate separable Gaussian.</param>
    /// <param name="precision">Generate with this precision.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Gaussmat(double sigma, double minAmpl, bool? separable = null, Enums.Precision? precision = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(separable), separable);
        options.AddIfPresent(nameof(precision), precision);

        return Operation.Call("gaussmat", options, sigma, minAmpl) as Image;
    }

    /// <summary>
    /// Make a gaussnoise image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Gaussnoise(width, height, sigma: double, mean: double, seed: int);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="sigma">Standard deviation of pixels in generated image.</param>
    /// <param name="mean">Mean of pixels in generated image.</param>
    /// <param name="seed">Random number seed.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Gaussnoise(int width, int height, double? sigma = null, double? mean = null, int? seed = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(sigma), sigma);
        options.AddIfPresent(nameof(mean), mean);
        options.AddIfPresent(nameof(seed), seed);

        return Operation.Call("gaussnoise", options, width, height) as Image;
    }

    /// <summary>
    /// Read a point from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double[] outArray = in.Getpoint(x, y, unpackComplex: bool);
    /// </code>
    /// </example>
    /// <param name="x">Point to read.</param>
    /// <param name="y">Point to read.</param>
    /// <param name="unpackComplex">Complex pixels should be unpacked.</param>
    /// <returns>An array of doubles.</returns>
    public double[] Getpoint(int x, int y, bool? unpackComplex = null)
    {
        var options = new VOption();

        options.AddIfPresent("unpack_complex", unpackComplex);

        return this.Call("getpoint", options, x, y) as double[];
    }

    /// <summary>
    /// Load GIF with libnsgif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Gifload(filename, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Gifload(string filename, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("gifload", options, filename) as Image;
    }

    /// <summary>
    /// Load GIF with libnsgif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Gifload(filename, out var flags, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Gifload(string filename, out Enums.ForeignFlags flags, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("gifload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load GIF with libnsgif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.GifloadBuffer(buffer, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image GifloadBuffer(byte[] buffer, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("gifload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load GIF with libnsgif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.GifloadBuffer(buffer, out var flags, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image GifloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("gifload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load gif from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.GifloadSource(source, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image GifloadSource(Source source, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("gifload_source", options, source) as Image;
    }

    /// <summary>
    /// Load gif from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.GifloadStream(stream, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image GifloadStream(Stream stream, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = GifloadSource(source, n, page, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load gif from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.GifloadSource(source, out var flags, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image GifloadSource(Source source, out Enums.ForeignFlags flags, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("gifload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load gif from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.GifloadStream(stream, out var flags, n: int, page: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image GifloadStream(Stream stream, out Enums.ForeignFlags flags, int? n = null, int? page = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = GifloadSource(source, out flags, n, page, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save as gif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Gifsave(filename, dither: double, effort: int, bitdepth: int, interframeMaxerror: double, reuse: bool, interpaletteMaxerror: double, interlace: bool, keepDuplicateFrames: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="effort">Quantisation effort.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="interframeMaxerror">Maximum inter-frame error for transparency.</param>
    /// <param name="reuse">Reuse palette from input.</param>
    /// <param name="interpaletteMaxerror">Maximum inter-palette error for palette reusage.</param>
    /// <param name="interlace">Generate an interlaced (progressive) GIF.</param>
    /// <param name="keepDuplicateFrames">Keep duplicate frames in the output instead of combining them.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Gifsave(string filename, double? dither = null, int? effort = null, int? bitdepth = null, double? interframeMaxerror = null, bool? reuse = null, double? interpaletteMaxerror = null, bool? interlace = null, bool? keepDuplicateFrames = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dither), dither);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent("interframe_maxerror", interframeMaxerror);
        options.AddIfPresent(nameof(reuse), reuse);
        options.AddIfPresent("interpalette_maxerror", interpaletteMaxerror);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("keep_duplicate_frames", keepDuplicateFrames);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("gifsave", options, filename);
    }

    /// <summary>
    /// Save as gif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.GifsaveBuffer(dither: double, effort: int, bitdepth: int, interframeMaxerror: double, reuse: bool, interpaletteMaxerror: double, interlace: bool, keepDuplicateFrames: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="effort">Quantisation effort.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="interframeMaxerror">Maximum inter-frame error for transparency.</param>
    /// <param name="reuse">Reuse palette from input.</param>
    /// <param name="interpaletteMaxerror">Maximum inter-palette error for palette reusage.</param>
    /// <param name="interlace">Generate an interlaced (progressive) GIF.</param>
    /// <param name="keepDuplicateFrames">Keep duplicate frames in the output instead of combining them.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] GifsaveBuffer(double? dither = null, int? effort = null, int? bitdepth = null, double? interframeMaxerror = null, bool? reuse = null, double? interpaletteMaxerror = null, bool? interlace = null, bool? keepDuplicateFrames = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dither), dither);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent("interframe_maxerror", interframeMaxerror);
        options.AddIfPresent(nameof(reuse), reuse);
        options.AddIfPresent("interpalette_maxerror", interpaletteMaxerror);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("keep_duplicate_frames", keepDuplicateFrames);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("gifsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save as gif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.GifsaveTarget(target, dither: double, effort: int, bitdepth: int, interframeMaxerror: double, reuse: bool, interpaletteMaxerror: double, interlace: bool, keepDuplicateFrames: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="effort">Quantisation effort.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="interframeMaxerror">Maximum inter-frame error for transparency.</param>
    /// <param name="reuse">Reuse palette from input.</param>
    /// <param name="interpaletteMaxerror">Maximum inter-palette error for palette reusage.</param>
    /// <param name="interlace">Generate an interlaced (progressive) GIF.</param>
    /// <param name="keepDuplicateFrames">Keep duplicate frames in the output instead of combining them.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void GifsaveTarget(Target target, double? dither = null, int? effort = null, int? bitdepth = null, double? interframeMaxerror = null, bool? reuse = null, double? interpaletteMaxerror = null, bool? interlace = null, bool? keepDuplicateFrames = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dither), dither);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent("interframe_maxerror", interframeMaxerror);
        options.AddIfPresent(nameof(reuse), reuse);
        options.AddIfPresent("interpalette_maxerror", interpaletteMaxerror);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("keep_duplicate_frames", keepDuplicateFrames);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("gifsave_target", options, target);
    }

    /// <summary>
    /// Save as gif.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.GifsaveStream(stream, dither: double, effort: int, bitdepth: int, interframeMaxerror: double, reuse: bool, interpaletteMaxerror: double, interlace: bool, keepDuplicateFrames: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="effort">Quantisation effort.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="interframeMaxerror">Maximum inter-frame error for transparency.</param>
    /// <param name="reuse">Reuse palette from input.</param>
    /// <param name="interpaletteMaxerror">Maximum inter-palette error for palette reusage.</param>
    /// <param name="interlace">Generate an interlaced (progressive) GIF.</param>
    /// <param name="keepDuplicateFrames">Keep duplicate frames in the output instead of combining them.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void GifsaveStream(Stream stream, double? dither = null, int? effort = null, int? bitdepth = null, double? interframeMaxerror = null, bool? reuse = null, double? interpaletteMaxerror = null, bool? interlace = null, bool? keepDuplicateFrames = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        GifsaveTarget(target, dither, effort, bitdepth, interframeMaxerror, reuse, interpaletteMaxerror, interlace, keepDuplicateFrames, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Global balance an image mosaic.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Globalbalance(gamma: double, intOutput: bool);
    /// </code>
    /// </example>
    /// <param name="gamma">Image gamma.</param>
    /// <param name="intOutput">Integer output.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Globalbalance(double? gamma = null, bool? intOutput = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(gamma), gamma);
        options.AddIfPresent("int_output", intOutput);

        return this.Call("globalbalance", options) as Image;
    }

    /// <summary>
    /// Place an image within a larger image with a certain gravity.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Gravity(direction, width, height, extend: Enums.Extend, background: double[]);
    /// </code>
    /// </example>
    /// <param name="direction">Direction to place image within width/height.</param>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="extend">How to generate the extra pixels.</param>
    /// <param name="background">Color for background pixels.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Gravity(Enums.CompassDirection direction, int width, int height, Enums.Extend? extend = null, double[] background = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(extend), extend);
        options.AddIfPresent(nameof(background), background);

        return this.Call("gravity", options, direction, width, height) as Image;
    }

    /// <summary>
    /// Make a grey ramp image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Grey(width, height, uchar: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Grey(int width, int height, bool? uchar = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);

        return Operation.Call("grey", options, width, height) as Image;
    }

    /// <summary>
    /// Grid an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Grid(tileHeight, across, down);
    /// </code>
    /// </example>
    /// <param name="tileHeight">Chop into tiles this high.</param>
    /// <param name="across">Number of tiles across.</param>
    /// <param name="down">Number of tiles down.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Grid(int tileHeight, int across, int down)
    {
        return this.Call("grid", tileHeight, across, down) as Image;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Heifload(filename, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Heifload(string filename, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(thumbnail), thumbnail);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("heifload", options, filename) as Image;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Heifload(filename, out var flags, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Heifload(string filename, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(thumbnail), thumbnail);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("heifload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.HeifloadBuffer(buffer, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image HeifloadBuffer(byte[] buffer, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(thumbnail), thumbnail);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("heifload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.HeifloadBuffer(buffer, out var flags, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image HeifloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(thumbnail), thumbnail);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("heifload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.HeifloadSource(source, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image HeifloadSource(Source source, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(thumbnail), thumbnail);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("heifload_source", options, source) as Image;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.HeifloadStream(stream, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image HeifloadStream(Stream stream, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = HeifloadSource(source, page, n, thumbnail, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.HeifloadSource(source, out var flags, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image HeifloadSource(Source source, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(thumbnail), thumbnail);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("heifload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load a HEIF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.HeifloadStream(stream, out var flags, page: int, n: int, thumbnail: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="thumbnail">Fetch thumbnail image.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image HeifloadStream(Stream stream, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? thumbnail = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = HeifloadSource(source, out flags, page, n, thumbnail, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image in HEIF format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Heifsave(filename, q: int, bitdepth: int, lossless: bool, compression: Enums.ForeignHeifCompression, effort: int, subsampleMode: Enums.ForeignSubsample, encoder: Enums.ForeignHeifEncoder, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="compression">Compression format.</param>
    /// <param name="effort">CPU effort.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="encoder">Select encoder to use.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Heifsave(string filename, int? q = null, int? bitdepth = null, bool? lossless = null, Enums.ForeignHeifCompression? compression = null, int? effort = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignHeifEncoder? encoder = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent(nameof(encoder), encoder);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("heifsave", options, filename);
    }

    /// <summary>
    /// Save image in HEIF format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.HeifsaveBuffer(q: int, bitdepth: int, lossless: bool, compression: Enums.ForeignHeifCompression, effort: int, subsampleMode: Enums.ForeignSubsample, encoder: Enums.ForeignHeifEncoder, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="q">Q factor.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="compression">Compression format.</param>
    /// <param name="effort">CPU effort.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="encoder">Select encoder to use.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] HeifsaveBuffer(int? q = null, int? bitdepth = null, bool? lossless = null, Enums.ForeignHeifCompression? compression = null, int? effort = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignHeifEncoder? encoder = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent(nameof(encoder), encoder);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("heifsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image in HEIF format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.HeifsaveTarget(target, q: int, bitdepth: int, lossless: bool, compression: Enums.ForeignHeifCompression, effort: int, subsampleMode: Enums.ForeignSubsample, encoder: Enums.ForeignHeifEncoder, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="compression">Compression format.</param>
    /// <param name="effort">CPU effort.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="encoder">Select encoder to use.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void HeifsaveTarget(Target target, int? q = null, int? bitdepth = null, bool? lossless = null, Enums.ForeignHeifCompression? compression = null, int? effort = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignHeifEncoder? encoder = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent(nameof(encoder), encoder);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("heifsave_target", options, target);
    }

    /// <summary>
    /// Save image in HEIF format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.HeifsaveStream(stream, q: int, bitdepth: int, lossless: bool, compression: Enums.ForeignHeifCompression, effort: int, subsampleMode: Enums.ForeignSubsample, encoder: Enums.ForeignHeifEncoder, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="compression">Compression format.</param>
    /// <param name="effort">CPU effort.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="encoder">Select encoder to use.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void HeifsaveStream(Stream stream, int? q = null, int? bitdepth = null, bool? lossless = null, Enums.ForeignHeifCompression? compression = null, int? effort = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignHeifEncoder? encoder = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        HeifsaveTarget(target, q, bitdepth, lossless, compression, effort, subsampleMode, encoder, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Form cumulative histogram.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistCum();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistCum()
    {
        return this.Call("hist_cum") as Image;
    }

    /// <summary>
    /// Estimate image entropy.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.HistEntropy();
    /// </code>
    /// </example>
    /// <returns>A double.</returns>
    public double HistEntropy()
    {
        return this.Call("hist_entropy") is double result ? result : 0d;
    }

    /// <summary>
    /// Histogram equalisation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistEqual(band: int);
    /// </code>
    /// </example>
    /// <param name="band">Equalise with this band.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistEqual(int? band = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(band), band);

        return this.Call("hist_equal", options) as Image;
    }

    /// <summary>
    /// Find image histogram.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistFind(band: int);
    /// </code>
    /// </example>
    /// <param name="band">Find histogram of band.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistFind(int? band = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(band), band);

        return this.Call("hist_find", options) as Image;
    }

    /// <summary>
    /// Find indexed image histogram.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistFindIndexed(index, combine: Enums.Combine);
    /// </code>
    /// </example>
    /// <param name="index">Index image.</param>
    /// <param name="combine">Combine bins like this.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistFindIndexed(Image index, Enums.Combine? combine = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(combine), combine);

        return this.Call("hist_find_indexed", options, index) as Image;
    }

    /// <summary>
    /// Find n-dimensional image histogram.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistFindNdim(bins: int);
    /// </code>
    /// </example>
    /// <param name="bins">Number of bins in each dimension.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistFindNdim(int? bins = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(bins), bins);

        return this.Call("hist_find_ndim", options) as Image;
    }

    /// <summary>
    /// Test for monotonicity.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// bool monotonic = in.HistIsmonotonic();
    /// </code>
    /// </example>
    /// <returns>A bool.</returns>
    public bool HistIsmonotonic()
    {
        return this.Call("hist_ismonotonic") is bool result && result;
    }

    /// <summary>
    /// Local histogram equalisation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistLocal(width, height, maxSlope: int);
    /// </code>
    /// </example>
    /// <param name="width">Window width in pixels.</param>
    /// <param name="height">Window height in pixels.</param>
    /// <param name="maxSlope">Maximum slope (CLAHE).</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistLocal(int width, int height, int? maxSlope = null)
    {
        var options = new VOption();

        options.AddIfPresent("max_slope", maxSlope);

        return this.Call("hist_local", options, width, height) as Image;
    }

    /// <summary>
    /// Match two histograms.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistMatch(@ref);
    /// </code>
    /// </example>
    /// <param name="ref">Reference histogram.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistMatch(Image @ref)
    {
        return this.Call("hist_match", @ref) as Image;
    }

    /// <summary>
    /// Normalise histogram.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistNorm();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistNorm()
    {
        return this.Call("hist_norm") as Image;
    }

    /// <summary>
    /// Plot histogram.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HistPlot();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HistPlot()
    {
        return this.Call("hist_plot") as Image;
    }

    /// <summary>
    /// Find hough circle transform.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HoughCircle(scale: int, minRadius: int, maxRadius: int);
    /// </code>
    /// </example>
    /// <param name="scale">Scale down dimensions by this factor.</param>
    /// <param name="minRadius">Smallest radius to search for.</param>
    /// <param name="maxRadius">Largest radius to search for.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HoughCircle(int? scale = null, int? minRadius = null, int? maxRadius = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent("min_radius", minRadius);
        options.AddIfPresent("max_radius", maxRadius);

        return this.Call("hough_circle", options) as Image;
    }

    /// <summary>
    /// Find hough line transform.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HoughLine(width: int, height: int);
    /// </code>
    /// </example>
    /// <param name="width">Horizontal size of parameter space.</param>
    /// <param name="height">Vertical size of parameter space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HoughLine(int? width = null, int? height = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(width), width);
        options.AddIfPresent(nameof(height), height);

        return this.Call("hough_line", options) as Image;
    }

    /// <summary>
    /// Transform HSV to sRGB.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.HSV2sRGB();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image HSV2sRGB()
    {
        return this.Call("HSV2sRGB") as Image;
    }

    /// <summary>
    /// Output to device with ICC profile.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.IccExport(pcs: Enums.PCS, intent: Enums.Intent, blackPointCompensation: bool, outputProfile: string, depth: int);
    /// </code>
    /// </example>
    /// <param name="pcs">Set Profile Connection Space.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="blackPointCompensation">Enable black point compensation.</param>
    /// <param name="outputProfile">Filename to load output profile from.</param>
    /// <param name="depth">Output device space depth in bits.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image IccExport(Enums.PCS? pcs = null, Enums.Intent? intent = null, bool? blackPointCompensation = null, string outputProfile = null, int? depth = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(pcs), pcs);
        options.AddIfPresent(nameof(intent), intent);
        options.AddIfPresent("black_point_compensation", blackPointCompensation);
        options.AddIfPresent("output_profile", outputProfile);
        options.AddIfPresent(nameof(depth), depth);

        return this.Call("icc_export", options) as Image;
    }

    /// <summary>
    /// Import from device with ICC profile.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.IccImport(pcs: Enums.PCS, intent: Enums.Intent, blackPointCompensation: bool, embedded: bool, inputProfile: string);
    /// </code>
    /// </example>
    /// <param name="pcs">Set Profile Connection Space.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="blackPointCompensation">Enable black point compensation.</param>
    /// <param name="embedded">Use embedded input profile, if available.</param>
    /// <param name="inputProfile">Filename to load input profile from.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image IccImport(Enums.PCS? pcs = null, Enums.Intent? intent = null, bool? blackPointCompensation = null, bool? embedded = null, string inputProfile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(pcs), pcs);
        options.AddIfPresent(nameof(intent), intent);
        options.AddIfPresent("black_point_compensation", blackPointCompensation);
        options.AddIfPresent(nameof(embedded), embedded);
        options.AddIfPresent("input_profile", inputProfile);

        return this.Call("icc_import", options) as Image;
    }

    /// <summary>
    /// Transform between devices with ICC profiles.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.IccTransform(outputProfile, pcs: Enums.PCS, intent: Enums.Intent, blackPointCompensation: bool, embedded: bool, inputProfile: string, depth: int);
    /// </code>
    /// </example>
    /// <param name="outputProfile">Filename to load output profile from.</param>
    /// <param name="pcs">Set Profile Connection Space.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="blackPointCompensation">Enable black point compensation.</param>
    /// <param name="embedded">Use embedded input profile, if available.</param>
    /// <param name="inputProfile">Filename to load input profile from.</param>
    /// <param name="depth">Output device space depth in bits.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image IccTransform(string outputProfile, Enums.PCS? pcs = null, Enums.Intent? intent = null, bool? blackPointCompensation = null, bool? embedded = null, string inputProfile = null, int? depth = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(pcs), pcs);
        options.AddIfPresent(nameof(intent), intent);
        options.AddIfPresent("black_point_compensation", blackPointCompensation);
        options.AddIfPresent(nameof(embedded), embedded);
        options.AddIfPresent("input_profile", inputProfile);
        options.AddIfPresent(nameof(depth), depth);

        return this.Call("icc_transform", options, outputProfile) as Image;
    }

    /// <summary>
    /// Make a 1D image where pixel values are indexes.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Identity(bands: int, @ushort: bool, size: int);
    /// </code>
    /// </example>
    /// <param name="bands">Number of bands in LUT.</param>
    /// <param name="ushort">Create a 16-bit LUT.</param>
    /// <param name="size">Size of 16-bit LUT.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Identity(int? bands = null, bool? @ushort = null, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(bands), bands);
        options.AddIfPresent("ushort", @ushort);
        options.AddIfPresent(nameof(size), size);

        return Operation.Call("identity", options) as Image;
    }

    /// <summary>
    /// Insert image @sub into @main at @x, @y.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = main.Insert(sub, x, y, expand: bool, background: double[]);
    /// </code>
    /// </example>
    /// <param name="sub">Sub-image to insert into main image.</param>
    /// <param name="x">Left edge of sub in main.</param>
    /// <param name="y">Top edge of sub in main.</param>
    /// <param name="expand">Expand output to hold all of both inputs.</param>
    /// <param name="background">Color for new pixels.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Insert(Image sub, int x, int y, bool? expand = null, double[] background = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(expand), expand);
        options.AddIfPresent(nameof(background), background);

        return this.Call("insert", options, sub, x, y) as Image;
    }

    /// <summary>
    /// Invert an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Invert();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Invert()
    {
        return this.Call("invert") as Image;
    }

    /// <summary>
    /// Build an inverted look-up table.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Invertlut(size: int);
    /// </code>
    /// </example>
    /// <param name="size">LUT size to generate.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Invertlut(int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        return this.Call("invertlut", options) as Image;
    }

    /// <summary>
    /// Inverse FFT.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Invfft(real: bool);
    /// </code>
    /// </example>
    /// <param name="real">Output only the real part of the transform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Invfft(bool? real = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(real), real);

        return this.Call("invfft", options) as Image;
    }

    /// <summary>
    /// Join a pair of images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in1.Join(in2, direction, expand: bool, shim: int, background: double[], align: Enums.Align);
    /// </code>
    /// </example>
    /// <param name="in2">Second input image.</param>
    /// <param name="direction">Join left-right or up-down.</param>
    /// <param name="expand">Expand output to hold all of both inputs.</param>
    /// <param name="shim">Pixels between images.</param>
    /// <param name="background">Colour for new pixels.</param>
    /// <param name="align">Align on the low, centre or high coordinate edge.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Join(Image in2, Enums.Direction direction, bool? expand = null, int? shim = null, double[] background = null, Enums.Align? align = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(expand), expand);
        options.AddIfPresent(nameof(shim), shim);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(align), align);

        return this.Call("join", options, in2, direction) as Image;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kload(filename, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kload(string filename, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(oneshot), oneshot);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jp2kload", options, filename) as Image;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kload(filename, out var flags, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kload(string filename, out Enums.ForeignFlags flags, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(oneshot), oneshot);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jp2kload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kloadBuffer(buffer, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kloadBuffer(byte[] buffer, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(oneshot), oneshot);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jp2kload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kloadBuffer(buffer, out var flags, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(oneshot), oneshot);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jp2kload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kloadSource(source, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kloadSource(Source source, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(oneshot), oneshot);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jp2kload_source", options, source) as Image;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kloadStream(stream, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kloadStream(Stream stream, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = Jp2kloadSource(source, page, oneshot, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kloadSource(source, out var flags, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kloadSource(Source source, out Enums.ForeignFlags flags, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(oneshot), oneshot);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jp2kload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load JPEG2000 image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jp2kloadStream(stream, out var flags, page: int, oneshot: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">Load this page from the image.</param>
    /// <param name="oneshot">Load images a frame at a time.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jp2kloadStream(Stream stream, out Enums.ForeignFlags flags, int? page = null, bool? oneshot = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = Jp2kloadSource(source, out flags, page, oneshot, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image in JPEG2000 format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Jp2ksave(filename, tileWidth: int, tileHeight: int, lossless: bool, q: int, subsampleMode: Enums.ForeignSubsample, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Jp2ksave(string filename, int? tileWidth = null, int? tileHeight = null, bool? lossless = null, int? q = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent("Q", q);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jp2ksave", options, filename);
    }

    /// <summary>
    /// Save image in JPEG2000 format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.Jp2ksaveBuffer(tileWidth: int, tileHeight: int, lossless: bool, q: int, subsampleMode: Enums.ForeignSubsample, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] Jp2ksaveBuffer(int? tileWidth = null, int? tileHeight = null, bool? lossless = null, int? q = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent("Q", q);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("jp2ksave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image in JPEG2000 format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Jp2ksaveTarget(target, tileWidth: int, tileHeight: int, lossless: bool, q: int, subsampleMode: Enums.ForeignSubsample, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Jp2ksaveTarget(Target target, int? tileWidth = null, int? tileHeight = null, bool? lossless = null, int? q = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent("Q", q);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jp2ksave_target", options, target);
    }

    /// <summary>
    /// Save image in JPEG2000 format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Jp2ksaveStream(stream, tileWidth: int, tileHeight: int, lossless: bool, q: int, subsampleMode: Enums.ForeignSubsample, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Jp2ksaveStream(Stream stream, int? tileWidth = null, int? tileHeight = null, bool? lossless = null, int? q = null, Enums.ForeignSubsample? subsampleMode = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        Jp2ksaveTarget(target, tileWidth, tileHeight, lossless, q, subsampleMode, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Load jpeg from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jpegload(filename, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jpegload(string filename, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shrink), shrink);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jpegload", options, filename) as Image;
    }

    /// <summary>
    /// Load jpeg from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jpegload(filename, out var flags, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jpegload(string filename, out Enums.ForeignFlags flags, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shrink), shrink);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jpegload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load jpeg from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JpegloadBuffer(buffer, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JpegloadBuffer(byte[] buffer, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shrink), shrink);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jpegload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load jpeg from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JpegloadBuffer(buffer, out var flags, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JpegloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shrink), shrink);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jpegload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load image from jpeg source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JpegloadSource(source, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JpegloadSource(Source source, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shrink), shrink);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jpegload_source", options, source) as Image;
    }

    /// <summary>
    /// Load image from jpeg stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JpegloadStream(stream, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JpegloadStream(Stream stream, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = JpegloadSource(source, shrink, autorotate, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load image from jpeg source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JpegloadSource(source, out var flags, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JpegloadSource(Source source, out Enums.ForeignFlags flags, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(shrink), shrink);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jpegload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load image from jpeg stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JpegloadStream(stream, out var flags, shrink: int, autorotate: bool, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="shrink">Shrink factor on load.</param>
    /// <param name="autorotate">Rotate image using exif orientation.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JpegloadStream(Stream stream, out Enums.ForeignFlags flags, int? shrink = null, bool? autorotate = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = JpegloadSource(source, out flags, shrink, autorotate, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to jpeg file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Jpegsave(filename, q: int, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: Enums.ForeignSubsample, restartInterval: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
    /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
    /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
    /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
    /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
    /// <param name="quantTable">Use predefined quantization table with given index.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="restartInterval">Add restart markers every specified number of mcu.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Jpegsave(string filename, int? q = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, Enums.ForeignSubsample? subsampleMode = null, int? restartInterval = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent("optimize_coding", optimizeCoding);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("trellis_quant", trellisQuant);
        options.AddIfPresent("overshoot_deringing", overshootDeringing);
        options.AddIfPresent("optimize_scans", optimizeScans);
        options.AddIfPresent("quant_table", quantTable);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent("restart_interval", restartInterval);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jpegsave", options, filename);
    }

    /// <summary>
    /// Save image to jpeg buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.JpegsaveBuffer(q: int, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: Enums.ForeignSubsample, restartInterval: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="q">Q factor.</param>
    /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
    /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
    /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
    /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
    /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
    /// <param name="quantTable">Use predefined quantization table with given index.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="restartInterval">Add restart markers every specified number of mcu.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] JpegsaveBuffer(int? q = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, Enums.ForeignSubsample? subsampleMode = null, int? restartInterval = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent("optimize_coding", optimizeCoding);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("trellis_quant", trellisQuant);
        options.AddIfPresent("overshoot_deringing", overshootDeringing);
        options.AddIfPresent("optimize_scans", optimizeScans);
        options.AddIfPresent("quant_table", quantTable);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent("restart_interval", restartInterval);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("jpegsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image to jpeg mime.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.JpegsaveMime(q: int, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: Enums.ForeignSubsample, restartInterval: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="q">Q factor.</param>
    /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
    /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
    /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
    /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
    /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
    /// <param name="quantTable">Use predefined quantization table with given index.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="restartInterval">Add restart markers every specified number of mcu.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void JpegsaveMime(int? q = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, Enums.ForeignSubsample? subsampleMode = null, int? restartInterval = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent("optimize_coding", optimizeCoding);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("trellis_quant", trellisQuant);
        options.AddIfPresent("overshoot_deringing", overshootDeringing);
        options.AddIfPresent("optimize_scans", optimizeScans);
        options.AddIfPresent("quant_table", quantTable);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent("restart_interval", restartInterval);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jpegsave_mime", options);
    }

    /// <summary>
    /// Save image to jpeg target.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.JpegsaveTarget(target, q: int, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: Enums.ForeignSubsample, restartInterval: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
    /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
    /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
    /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
    /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
    /// <param name="quantTable">Use predefined quantization table with given index.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="restartInterval">Add restart markers every specified number of mcu.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void JpegsaveTarget(Target target, int? q = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, Enums.ForeignSubsample? subsampleMode = null, int? restartInterval = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent("optimize_coding", optimizeCoding);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent("trellis_quant", trellisQuant);
        options.AddIfPresent("overshoot_deringing", overshootDeringing);
        options.AddIfPresent("optimize_scans", optimizeScans);
        options.AddIfPresent("quant_table", quantTable);
        options.AddIfPresent("subsample_mode", subsampleMode);
        options.AddIfPresent("restart_interval", restartInterval);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jpegsave_target", options, target);
    }

    /// <summary>
    /// Save image to jpeg stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.JpegsaveStream(stream, q: int, optimizeCoding: bool, interlace: bool, trellisQuant: bool, overshootDeringing: bool, optimizeScans: bool, quantTable: int, subsampleMode: Enums.ForeignSubsample, restartInterval: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="optimizeCoding">Compute optimal Huffman coding tables.</param>
    /// <param name="interlace">Generate an interlaced (progressive) jpeg.</param>
    /// <param name="trellisQuant">Apply trellis quantisation to each 8x8 block.</param>
    /// <param name="overshootDeringing">Apply overshooting to samples with extreme values.</param>
    /// <param name="optimizeScans">Split spectrum of DCT coefficients into separate scans.</param>
    /// <param name="quantTable">Use predefined quantization table with given index.</param>
    /// <param name="subsampleMode">Select chroma subsample operation mode.</param>
    /// <param name="restartInterval">Add restart markers every specified number of mcu.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void JpegsaveStream(Stream stream, int? q = null, bool? optimizeCoding = null, bool? interlace = null, bool? trellisQuant = null, bool? overshootDeringing = null, bool? optimizeScans = null, int? quantTable = null, Enums.ForeignSubsample? subsampleMode = null, int? restartInterval = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        JpegsaveTarget(target, q, optimizeCoding, interlace, trellisQuant, overshootDeringing, optimizeScans, quantTable, subsampleMode, restartInterval, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jxlload(filename, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jxlload(string filename, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jxlload", options, filename) as Image;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Jxlload(filename, out var flags, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Jxlload(string filename, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jxlload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JxlloadBuffer(buffer, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JxlloadBuffer(byte[] buffer, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jxlload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JxlloadBuffer(buffer, out var flags, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JxlloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jxlload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JxlloadSource(source, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JxlloadSource(Source source, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("jxlload_source", options, source) as Image;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JxlloadStream(stream, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JxlloadStream(Stream stream, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = JxlloadSource(source, page, n, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JxlloadSource(source, out var flags, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JxlloadSource(Source source, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("jxlload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load JPEG-XL image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.JxlloadStream(stream, out var flags, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image JxlloadStream(Stream stream, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = JxlloadSource(source, out flags, page, n, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image in JPEG-XL format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Jxlsave(filename, tier: int, distance: double, effort: int, lossless: bool, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="tier">Decode speed tier.</param>
    /// <param name="distance">Target butteraugli distance.</param>
    /// <param name="effort">Encoding effort.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Quality factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Jxlsave(string filename, int? tier = null, double? distance = null, int? effort = null, bool? lossless = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(tier), tier);
        options.AddIfPresent(nameof(distance), distance);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent("Q", q);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jxlsave", options, filename);
    }

    /// <summary>
    /// Save image in JPEG-XL format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.JxlsaveBuffer(tier: int, distance: double, effort: int, lossless: bool, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="tier">Decode speed tier.</param>
    /// <param name="distance">Target butteraugli distance.</param>
    /// <param name="effort">Encoding effort.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Quality factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] JxlsaveBuffer(int? tier = null, double? distance = null, int? effort = null, bool? lossless = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(tier), tier);
        options.AddIfPresent(nameof(distance), distance);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent("Q", q);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("jxlsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image in JPEG-XL format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.JxlsaveTarget(target, tier: int, distance: double, effort: int, lossless: bool, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="tier">Decode speed tier.</param>
    /// <param name="distance">Target butteraugli distance.</param>
    /// <param name="effort">Encoding effort.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Quality factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void JxlsaveTarget(Target target, int? tier = null, double? distance = null, int? effort = null, bool? lossless = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(tier), tier);
        options.AddIfPresent(nameof(distance), distance);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent("Q", q);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("jxlsave_target", options, target);
    }

    /// <summary>
    /// Save image in JPEG-XL format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.JxlsaveStream(stream, tier: int, distance: double, effort: int, lossless: bool, q: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="tier">Decode speed tier.</param>
    /// <param name="distance">Target butteraugli distance.</param>
    /// <param name="effort">Encoding effort.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="q">Quality factor.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void JxlsaveStream(Stream stream, int? tier = null, double? distance = null, int? effort = null, bool? lossless = null, int? q = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        JxlsaveTarget(target, tier, distance, effort, lossless, q, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Transform float Lab to LabQ coding.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Lab2LabQ();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Lab2LabQ()
    {
        return this.Call("Lab2LabQ") as Image;
    }

    /// <summary>
    /// Transform float Lab to signed short.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Lab2LabS();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Lab2LabS()
    {
        return this.Call("Lab2LabS") as Image;
    }

    /// <summary>
    /// Transform Lab to LCh.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Lab2LCh();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Lab2LCh()
    {
        return this.Call("Lab2LCh") as Image;
    }

    /// <summary>
    /// Transform CIELAB to XYZ.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Lab2XYZ(temp: double[]);
    /// </code>
    /// </example>
    /// <param name="temp">Color temperature.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Lab2XYZ(double[] temp = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(temp), temp);

        return this.Call("Lab2XYZ", options) as Image;
    }

    /// <summary>
    /// Label regions in an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image mask = in.Labelregions();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Labelregions()
    {
        return this.Call("labelregions") as Image;
    }

    /// <summary>
    /// Label regions in an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image mask = in.Labelregions(out var segments);
    /// </code>
    /// </example>
    /// <param name="segments">Number of discrete contiguous regions.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Labelregions(out int segments)
    {
        var optionalOutput = new VOption
        {
            {"segments", true}
        };

        var results = this.Call("labelregions", optionalOutput) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        segments = opts?["segments"] is int out1 ? out1 : 0;

        return finalResult;
    }

    /// <summary>
    /// Unpack a LabQ image to float Lab.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LabQ2Lab();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LabQ2Lab()
    {
        return this.Call("LabQ2Lab") as Image;
    }

    /// <summary>
    /// Unpack a LabQ image to short Lab.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LabQ2LabS();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LabQ2LabS()
    {
        return this.Call("LabQ2LabS") as Image;
    }

    /// <summary>
    /// Convert a LabQ image to sRGB.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LabQ2sRGB();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LabQ2sRGB()
    {
        return this.Call("LabQ2sRGB") as Image;
    }

    /// <summary>
    /// Transform signed short Lab to float.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LabS2Lab();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LabS2Lab()
    {
        return this.Call("LabS2Lab") as Image;
    }

    /// <summary>
    /// Transform short Lab to LabQ coding.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LabS2LabQ();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LabS2LabQ()
    {
        return this.Call("LabS2LabQ") as Image;
    }

    /// <summary>
    /// Transform LCh to CMC.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LCh2CMC();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LCh2CMC()
    {
        return this.Call("LCh2CMC") as Image;
    }

    /// <summary>
    /// Transform LCh to Lab.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.LCh2Lab();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image LCh2Lab()
    {
        return this.Call("LCh2Lab") as Image;
    }

    /// <summary>
    /// Calculate (a * in + b).
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Linear(a, b, uchar: bool);
    /// </code>
    /// </example>
    /// <param name="a">Multiply by this.</param>
    /// <param name="b">Add this.</param>
    /// <param name="uchar">Output should be uchar.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Linear(double[] a, double[] b, bool? uchar = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);

        return this.Call("linear", options, a, b) as Image;
    }

    /// <summary>
    /// Cache an image as a set of lines.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Linecache(tileHeight: int, access: Enums.Access, threaded: bool, persistent: bool);
    /// </code>
    /// </example>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="access">Expected access pattern.</param>
    /// <param name="threaded">Allow threaded access.</param>
    /// <param name="persistent">Keep cache between evaluations.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Linecache(int? tileHeight = null, Enums.Access? access = null, bool? threaded = null, bool? persistent = null)
    {
        var options = new VOption();

        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(access), access);
        options.AddIfPresent(nameof(threaded), threaded);
        options.AddIfPresent(nameof(persistent), persistent);

        return this.Call("linecache", options) as Image;
    }

    /// <summary>
    /// Make a Laplacian of Gaussian image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Logmat(sigma, minAmpl, separable: bool, precision: Enums.Precision);
    /// </code>
    /// </example>
    /// <param name="sigma">Radius of Gaussian.</param>
    /// <param name="minAmpl">Minimum amplitude of Gaussian.</param>
    /// <param name="separable">Generate separable Gaussian.</param>
    /// <param name="precision">Generate with this precision.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Logmat(double sigma, double minAmpl, bool? separable = null, Enums.Precision? precision = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(separable), separable);
        options.AddIfPresent(nameof(precision), precision);

        return Operation.Call("logmat", options, sigma, minAmpl) as Image;
    }

    /// <summary>
    /// Load file with ImageMagick.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Magickload(filename, density: string, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Magickload(string filename, string density = null, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(density), density);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("magickload", options, filename) as Image;
    }

    /// <summary>
    /// Load file with ImageMagick.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Magickload(filename, out var flags, density: string, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Magickload(string filename, out Enums.ForeignFlags flags, string density = null, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(density), density);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("magickload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load buffer with ImageMagick.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MagickloadBuffer(buffer, density: string, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MagickloadBuffer(byte[] buffer, string density = null, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(density), density);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("magickload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load buffer with ImageMagick.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MagickloadBuffer(buffer, out var flags, density: string, page: int, n: int, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="density">Canvas resolution for rendering vector formats like SVG.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MagickloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, string density = null, int? page = null, int? n = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(density), density);
        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("magickload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Save file with ImageMagick.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Magicksave(filename, format: string, quality: int, optimizeGifFrames: bool, optimizeGifTransparency: bool, bitdepth: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="format">Format to save in.</param>
    /// <param name="quality">Quality to use.</param>
    /// <param name="optimizeGifFrames">Apply GIF frames optimization.</param>
    /// <param name="optimizeGifTransparency">Apply GIF transparency optimization.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Magicksave(string filename, string format = null, int? quality = null, bool? optimizeGifFrames = null, bool? optimizeGifTransparency = null, int? bitdepth = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(quality), quality);
        options.AddIfPresent("optimize_gif_frames", optimizeGifFrames);
        options.AddIfPresent("optimize_gif_transparency", optimizeGifTransparency);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("magicksave", options, filename);
    }

    /// <summary>
    /// Save image to magick buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.MagicksaveBuffer(format: string, quality: int, optimizeGifFrames: bool, optimizeGifTransparency: bool, bitdepth: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="format">Format to save in.</param>
    /// <param name="quality">Quality to use.</param>
    /// <param name="optimizeGifFrames">Apply GIF frames optimization.</param>
    /// <param name="optimizeGifTransparency">Apply GIF transparency optimization.</param>
    /// <param name="bitdepth">Number of bits per pixel.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] MagicksaveBuffer(string format = null, int? quality = null, bool? optimizeGifFrames = null, bool? optimizeGifTransparency = null, int? bitdepth = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(quality), quality);
        options.AddIfPresent("optimize_gif_frames", optimizeGifFrames);
        options.AddIfPresent("optimize_gif_transparency", optimizeGifTransparency);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("magicksave_buffer", options) as byte[];
    }

    /// <summary>
    /// Resample with a map image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Mapim(index, interpolate: GObject, background: double[], premultiplied: bool, extend: Enums.Extend);
    /// </code>
    /// </example>
    /// <param name="index">Index pixels with this.</param>
    /// <param name="interpolate">Interpolate pixels with this.</param>
    /// <param name="background">Background value.</param>
    /// <param name="premultiplied">Images have premultiplied alpha.</param>
    /// <param name="extend">How to generate the extra pixels.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mapim(Image index, GObject interpolate = null, double[] background = null, bool? premultiplied = null, Enums.Extend? extend = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interpolate), interpolate);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(premultiplied), premultiplied);
        options.AddIfPresent(nameof(extend), extend);

        return this.Call("mapim", options, index) as Image;
    }

    /// <summary>
    /// Map an image though a lut.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Maplut(lut, band: int);
    /// </code>
    /// </example>
    /// <param name="lut">Look-up table image.</param>
    /// <param name="band">Apply one-band lut to this band of in.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Maplut(Image lut, int? band = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(band), band);

        return this.Call("maplut", options, lut) as Image;
    }

    /// <summary>
    /// Make a butterworth filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskButterworth(width, height, order, frequencyCutoff, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="order">Filter order.</param>
    /// <param name="frequencyCutoff">Frequency cutoff.</param>
    /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskButterworth(int width, int height, double order, double frequencyCutoff, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_butterworth", options, width, height, order, frequencyCutoff, amplitudeCutoff) as Image;
    }

    /// <summary>
    /// Make a butterworth_band filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskButterworthBand(width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="order">Filter order.</param>
    /// <param name="frequencyCutoffX">Frequency cutoff x.</param>
    /// <param name="frequencyCutoffY">Frequency cutoff y.</param>
    /// <param name="radius">Radius of circle.</param>
    /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskButterworthBand(int width, int height, double order, double frequencyCutoffX, double frequencyCutoffY, double radius, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_butterworth_band", options, width, height, order, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff) as Image;
    }

    /// <summary>
    /// Make a butterworth ring filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskButterworthRing(width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="order">Filter order.</param>
    /// <param name="frequencyCutoff">Frequency cutoff.</param>
    /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
    /// <param name="ringwidth">Ringwidth.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskButterworthRing(int width, int height, double order, double frequencyCutoff, double amplitudeCutoff, double ringwidth, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_butterworth_ring", options, width, height, order, frequencyCutoff, amplitudeCutoff, ringwidth) as Image;
    }

    /// <summary>
    /// Make fractal filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskFractal(width, height, fractalDimension, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="fractalDimension">Fractal dimension.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskFractal(int width, int height, double fractalDimension, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_fractal", options, width, height, fractalDimension) as Image;
    }

    /// <summary>
    /// Make a gaussian filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskGaussian(width, height, frequencyCutoff, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="frequencyCutoff">Frequency cutoff.</param>
    /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskGaussian(int width, int height, double frequencyCutoff, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_gaussian", options, width, height, frequencyCutoff, amplitudeCutoff) as Image;
    }

    /// <summary>
    /// Make a gaussian filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskGaussianBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="frequencyCutoffX">Frequency cutoff x.</param>
    /// <param name="frequencyCutoffY">Frequency cutoff y.</param>
    /// <param name="radius">Radius of circle.</param>
    /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskGaussianBand(int width, int height, double frequencyCutoffX, double frequencyCutoffY, double radius, double amplitudeCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_gaussian_band", options, width, height, frequencyCutoffX, frequencyCutoffY, radius, amplitudeCutoff) as Image;
    }

    /// <summary>
    /// Make a gaussian ring filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskGaussianRing(width, height, frequencyCutoff, amplitudeCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="frequencyCutoff">Frequency cutoff.</param>
    /// <param name="amplitudeCutoff">Amplitude cutoff.</param>
    /// <param name="ringwidth">Ringwidth.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskGaussianRing(int width, int height, double frequencyCutoff, double amplitudeCutoff, double ringwidth, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_gaussian_ring", options, width, height, frequencyCutoff, amplitudeCutoff, ringwidth) as Image;
    }

    /// <summary>
    /// Make an ideal filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskIdeal(width, height, frequencyCutoff, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="frequencyCutoff">Frequency cutoff.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskIdeal(int width, int height, double frequencyCutoff, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_ideal", options, width, height, frequencyCutoff) as Image;
    }

    /// <summary>
    /// Make an ideal band filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskIdealBand(width, height, frequencyCutoffX, frequencyCutoffY, radius, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="frequencyCutoffX">Frequency cutoff x.</param>
    /// <param name="frequencyCutoffY">Frequency cutoff y.</param>
    /// <param name="radius">Radius of circle.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskIdealBand(int width, int height, double frequencyCutoffX, double frequencyCutoffY, double radius, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_ideal_band", options, width, height, frequencyCutoffX, frequencyCutoffY, radius) as Image;
    }

    /// <summary>
    /// Make an ideal ring filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MaskIdealRing(width, height, frequencyCutoff, ringwidth, uchar: bool, nodc: bool, reject: bool, optical: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="frequencyCutoff">Frequency cutoff.</param>
    /// <param name="ringwidth">Ringwidth.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="nodc">Remove DC component.</param>
    /// <param name="reject">Invert the sense of the filter.</param>
    /// <param name="optical">Rotate quadrants to optical space.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MaskIdealRing(int width, int height, double frequencyCutoff, double ringwidth, bool? uchar = null, bool? nodc = null, bool? reject = null, bool? optical = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(nodc), nodc);
        options.AddIfPresent(nameof(reject), reject);
        options.AddIfPresent(nameof(optical), optical);

        return Operation.Call("mask_ideal_ring", options, width, height, frequencyCutoff, ringwidth) as Image;
    }

    /// <summary>
    /// First-order match of two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Match(sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, hwindow: int, harea: int, search: bool, interpolate: GObject);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="xr1">Position of first reference tie-point.</param>
    /// <param name="yr1">Position of first reference tie-point.</param>
    /// <param name="xs1">Position of first secondary tie-point.</param>
    /// <param name="ys1">Position of first secondary tie-point.</param>
    /// <param name="xr2">Position of second reference tie-point.</param>
    /// <param name="yr2">Position of second reference tie-point.</param>
    /// <param name="xs2">Position of second secondary tie-point.</param>
    /// <param name="ys2">Position of second secondary tie-point.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="search">Search to improve tie-points.</param>
    /// <param name="interpolate">Interpolate pixels with this.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Match(Image sec, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int? hwindow = null, int? harea = null, bool? search = null, GObject interpolate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(search), search);
        options.AddIfPresent(nameof(interpolate), interpolate);

        return this.Call("match", options, sec, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2) as Image;
    }

    /// <summary>
    /// Apply a math operation to an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Math(math);
    /// </code>
    /// </example>
    /// <param name="math">Math to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Math(Enums.OperationMath math)
    {
        return this.Call("math", math) as Image;
    }

    /// <summary>
    /// Binary math operations.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Math2(right, math2);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <param name="math2">Math to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Math2(Image right, Enums.OperationMath2 math2)
    {
        return this.Call("math2", right, math2) as Image;
    }

    /// <summary>
    /// Binary math operations with a constant.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Math2Const(math2, c);
    /// </code>
    /// </example>
    /// <param name="math2">Math to perform.</param>
    /// <param name="c">Array of constants.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Math2Const(Enums.OperationMath2 math2, double[] c)
    {
        return this.Call("math2_const", math2, c) as Image;
    }

    /// <summary>
    /// Load mat from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Matload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Matload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("matload", options, filename) as Image;
    }

    /// <summary>
    /// Load mat from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Matload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Matload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("matload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Invert a matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Matrixinvert();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Matrixinvert()
    {
        return this.Call("matrixinvert") as Image;
    }

    /// <summary>
    /// Load matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Matrixload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Matrixload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("matrixload", options, filename) as Image;
    }

    /// <summary>
    /// Load matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Matrixload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Matrixload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("matrixload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MatrixloadSource(source, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MatrixloadSource(Source source, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("matrixload_source", options, source) as Image;
    }

    /// <summary>
    /// Load matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MatrixloadStream(stream, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MatrixloadStream(Stream stream, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = MatrixloadSource(source, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MatrixloadSource(source, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MatrixloadSource(Source source, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("matrixload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.MatrixloadStream(stream, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image MatrixloadStream(Stream stream, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = MatrixloadSource(source, out flags, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Multiply two matrices.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Matrixmultiply(right);
    /// </code>
    /// </example>
    /// <param name="right">Second matrix to multiply.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Matrixmultiply(Image right)
    {
        return this.Call("matrixmultiply", right) as Image;
    }

    /// <summary>
    /// Print matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Matrixprint(keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Matrixprint(Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("matrixprint", options);
    }

    /// <summary>
    /// Save image to matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Matrixsave(filename, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Matrixsave(string filename, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("matrixsave", options, filename);
    }

    /// <summary>
    /// Save image to matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.MatrixsaveTarget(target, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void MatrixsaveTarget(Target target, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("matrixsave_target", options, target);
    }

    /// <summary>
    /// Save image to matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.MatrixsaveStream(stream, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void MatrixsaveStream(Stream stream, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        MatrixsaveTarget(target, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Find image maximum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Max(size: int);
    /// </code>
    /// </example>
    /// <param name="size">Number of maximum values to find.</param>
    /// <returns>A double.</returns>
    public double Max(int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        return this.Call("max", options) is double result ? result : 0d;
    }

    /// <summary>
    /// Find image maximum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Max(out var x, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of maximum.</param>
    /// <param name="size">Number of maximum values to find.</param>
    /// <returns>A double.</returns>
    public double Max(out int x, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);

        var results = this.Call("max", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;

        return finalResult;
    }

    /// <summary>
    /// Find image maximum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Max(out var x, out var y, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of maximum.</param>
    /// <param name="y">Vertical position of maximum.</param>
    /// <param name="size">Number of maximum values to find.</param>
    /// <returns>A double.</returns>
    public double Max(out int x, out int y, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);

        var results = this.Call("max", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;

        return finalResult;
    }

    /// <summary>
    /// Find image maximum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Max(out var x, out var y, out var outArray, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of maximum.</param>
    /// <param name="y">Vertical position of maximum.</param>
    /// <param name="outArray">Array of output values.</param>
    /// <param name="size">Number of maximum values to find.</param>
    /// <returns>A double.</returns>
    public double Max(out int x, out int y, out double[] outArray, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);
        options.Add("out_array", true);

        var results = this.Call("max", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;
        outArray = opts?["out_array"] as double[];

        return finalResult;
    }

    /// <summary>
    /// Find image maximum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Max(out var x, out var y, out var outArray, out var xArray, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of maximum.</param>
    /// <param name="y">Vertical position of maximum.</param>
    /// <param name="outArray">Array of output values.</param>
    /// <param name="xArray">Array of horizontal positions.</param>
    /// <param name="size">Number of maximum values to find.</param>
    /// <returns>A double.</returns>
    public double Max(out int x, out int y, out double[] outArray, out int[] xArray, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);
        options.Add("out_array", true);
        options.Add("x_array", true);

        var results = this.Call("max", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;
        outArray = opts?["out_array"] as double[];
        xArray = opts?["x_array"] as int[];

        return finalResult;
    }

    /// <summary>
    /// Find image maximum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Max(out var x, out var y, out var outArray, out var xArray, out var yArray, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of maximum.</param>
    /// <param name="y">Vertical position of maximum.</param>
    /// <param name="outArray">Array of output values.</param>
    /// <param name="xArray">Array of horizontal positions.</param>
    /// <param name="yArray">Array of vertical positions.</param>
    /// <param name="size">Number of maximum values to find.</param>
    /// <returns>A double.</returns>
    public double Max(out int x, out int y, out double[] outArray, out int[] xArray, out int[] yArray, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);
        options.Add("out_array", true);
        options.Add("x_array", true);
        options.Add("y_array", true);

        var results = this.Call("max", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;
        outArray = opts?["out_array"] as double[];
        xArray = opts?["x_array"] as int[];
        yArray = opts?["y_array"] as int[];

        return finalResult;
    }

    /// <summary>
    /// Maximum of a pair of images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Maxpair(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Maxpair(Image right)
    {
        return this.Call("maxpair", right) as Image;
    }

    /// <summary>
    /// Measure a set of patches on a color chart.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Measure(h, v, left: int, top: int, width: int, height: int);
    /// </code>
    /// </example>
    /// <param name="h">Number of patches across chart.</param>
    /// <param name="v">Number of patches down chart.</param>
    /// <param name="left">Left edge of extract area.</param>
    /// <param name="top">Top edge of extract area.</param>
    /// <param name="width">Width of extract area.</param>
    /// <param name="height">Height of extract area.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Measure(int h, int v, int? left = null, int? top = null, int? width = null, int? height = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(left), left);
        options.AddIfPresent(nameof(top), top);
        options.AddIfPresent(nameof(width), width);
        options.AddIfPresent(nameof(height), height);

        return this.Call("measure", options, h, v) as Image;
    }

    /// <summary>
    /// Merge two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Merge(sec, direction, dx, dy, mblend: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical merge.</param>
    /// <param name="dx">Horizontal displacement from sec to ref.</param>
    /// <param name="dy">Vertical displacement from sec to ref.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Merge(Image sec, Enums.Direction direction, int dx, int dy, int? mblend = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(mblend), mblend);

        return this.Call("merge", options, sec, direction, dx, dy) as Image;
    }

    /// <summary>
    /// Find image minimum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Min(size: int);
    /// </code>
    /// </example>
    /// <param name="size">Number of minimum values to find.</param>
    /// <returns>A double.</returns>
    public double Min(int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        return this.Call("min", options) is double result ? result : 0d;
    }

    /// <summary>
    /// Find image minimum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Min(out var x, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of minimum.</param>
    /// <param name="size">Number of minimum values to find.</param>
    /// <returns>A double.</returns>
    public double Min(out int x, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);

        var results = this.Call("min", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;

        return finalResult;
    }

    /// <summary>
    /// Find image minimum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Min(out var x, out var y, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of minimum.</param>
    /// <param name="y">Vertical position of minimum.</param>
    /// <param name="size">Number of minimum values to find.</param>
    /// <returns>A double.</returns>
    public double Min(out int x, out int y, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);

        var results = this.Call("min", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;

        return finalResult;
    }

    /// <summary>
    /// Find image minimum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Min(out var x, out var y, out var outArray, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of minimum.</param>
    /// <param name="y">Vertical position of minimum.</param>
    /// <param name="outArray">Array of output values.</param>
    /// <param name="size">Number of minimum values to find.</param>
    /// <returns>A double.</returns>
    public double Min(out int x, out int y, out double[] outArray, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);
        options.Add("out_array", true);

        var results = this.Call("min", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;
        outArray = opts?["out_array"] as double[];

        return finalResult;
    }

    /// <summary>
    /// Find image minimum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Min(out var x, out var y, out var outArray, out var xArray, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of minimum.</param>
    /// <param name="y">Vertical position of minimum.</param>
    /// <param name="outArray">Array of output values.</param>
    /// <param name="xArray">Array of horizontal positions.</param>
    /// <param name="size">Number of minimum values to find.</param>
    /// <returns>A double.</returns>
    public double Min(out int x, out int y, out double[] outArray, out int[] xArray, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);
        options.Add("out_array", true);
        options.Add("x_array", true);

        var results = this.Call("min", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;
        outArray = opts?["out_array"] as double[];
        xArray = opts?["x_array"] as int[];

        return finalResult;
    }

    /// <summary>
    /// Find image minimum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// double @out = in.Min(out var x, out var y, out var outArray, out var xArray, out var yArray, size: int);
    /// </code>
    /// </example>
    /// <param name="x">Horizontal position of minimum.</param>
    /// <param name="y">Vertical position of minimum.</param>
    /// <param name="outArray">Array of output values.</param>
    /// <param name="xArray">Array of horizontal positions.</param>
    /// <param name="yArray">Array of vertical positions.</param>
    /// <param name="size">Number of minimum values to find.</param>
    /// <returns>A double.</returns>
    public double Min(out int x, out int y, out double[] outArray, out int[] xArray, out int[] yArray, int? size = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(size), size);

        options.Add("x", true);
        options.Add("y", true);
        options.Add("out_array", true);
        options.Add("x_array", true);
        options.Add("y_array", true);

        var results = this.Call("min", options) as object[];
        var finalResult = results?[0] is double result ? result : 0d;
        var opts = results?[1] as VOption;
        x = opts?["x"] is int out1 ? out1 : 0;
        y = opts?["y"] is int out2 ? out2 : 0;
        outArray = opts?["out_array"] as double[];
        xArray = opts?["x_array"] as int[];
        yArray = opts?["y_array"] as int[];

        return finalResult;
    }

    /// <summary>
    /// Minimum of a pair of images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Minpair(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Minpair(Image right)
    {
        return this.Call("minpair", right) as Image;
    }

    /// <summary>
    /// Morphology operation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Morph(mask, morph);
    /// </code>
    /// </example>
    /// <param name="mask">Input matrix image.</param>
    /// <param name="morph">Morphological operation to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Morph(Image mask, Enums.OperationMorphology morph)
    {
        return this.Call("morph", mask, morph) as Image;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        return this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as Image;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="dx0">Detected integer offset.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, out int dx0, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        options.Add("dx0", true);

        var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        dx0 = opts?["dx0"] is int out1 ? out1 : 0;

        return finalResult;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="dx0">Detected integer offset.</param>
    /// <param name="dy0">Detected integer offset.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        options.Add("dx0", true);
        options.Add("dy0", true);

        var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        dx0 = opts?["dx0"] is int out1 ? out1 : 0;
        dy0 = opts?["dy0"] is int out2 ? out2 : 0;

        return finalResult;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="dx0">Detected integer offset.</param>
    /// <param name="dy0">Detected integer offset.</param>
    /// <param name="scale1">Detected scale.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        options.Add("dx0", true);
        options.Add("dy0", true);
        options.Add("scale1", true);

        var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        dx0 = opts?["dx0"] is int out1 ? out1 : 0;
        dy0 = opts?["dy0"] is int out2 ? out2 : 0;
        scale1 = opts?["scale1"] is double out3 ? out3 : 0d;

        return finalResult;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="dx0">Detected integer offset.</param>
    /// <param name="dy0">Detected integer offset.</param>
    /// <param name="scale1">Detected scale.</param>
    /// <param name="angle1">Detected rotation.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, out double angle1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        options.Add("dx0", true);
        options.Add("dy0", true);
        options.Add("scale1", true);
        options.Add("angle1", true);

        var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        dx0 = opts?["dx0"] is int out1 ? out1 : 0;
        dy0 = opts?["dy0"] is int out2 ? out2 : 0;
        scale1 = opts?["scale1"] is double out3 ? out3 : 0d;
        angle1 = opts?["angle1"] is double out4 ? out4 : 0d;

        return finalResult;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, out var dy1, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="dx0">Detected integer offset.</param>
    /// <param name="dy0">Detected integer offset.</param>
    /// <param name="scale1">Detected scale.</param>
    /// <param name="angle1">Detected rotation.</param>
    /// <param name="dy1">Detected first-order displacement.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, out double angle1, out double dy1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        options.Add("dx0", true);
        options.Add("dy0", true);
        options.Add("scale1", true);
        options.Add("angle1", true);
        options.Add("dy1", true);

        var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        dx0 = opts?["dx0"] is int out1 ? out1 : 0;
        dy0 = opts?["dy0"] is int out2 ? out2 : 0;
        scale1 = opts?["scale1"] is double out3 ? out3 : 0d;
        angle1 = opts?["angle1"] is double out4 ? out4 : 0d;
        dy1 = opts?["dy1"] is double out5 ? out5 : 0d;

        return finalResult;
    }

    /// <summary>
    /// Mosaic two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic(sec, direction, xref, yref, xsec, ysec, out var dx0, out var dy0, out var scale1, out var angle1, out var dy1, out var dx1, hwindow: int, harea: int, mblend: int, bandno: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xref">Position of reference tie-point.</param>
    /// <param name="yref">Position of reference tie-point.</param>
    /// <param name="xsec">Position of secondary tie-point.</param>
    /// <param name="ysec">Position of secondary tie-point.</param>
    /// <param name="dx0">Detected integer offset.</param>
    /// <param name="dy0">Detected integer offset.</param>
    /// <param name="scale1">Detected scale.</param>
    /// <param name="angle1">Detected rotation.</param>
    /// <param name="dy1">Detected first-order displacement.</param>
    /// <param name="dx1">Detected first-order displacement.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <param name="bandno">Band to search for features on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic(Image sec, Enums.Direction direction, int xref, int yref, int xsec, int ysec, out int dx0, out int dy0, out double scale1, out double angle1, out double dy1, out double dx1, int? hwindow = null, int? harea = null, int? mblend = null, int? bandno = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(mblend), mblend);
        options.AddIfPresent(nameof(bandno), bandno);

        options.Add("dx0", true);
        options.Add("dy0", true);
        options.Add("scale1", true);
        options.Add("angle1", true);
        options.Add("dy1", true);
        options.Add("dx1", true);

        var results = this.Call("mosaic", options, sec, direction, xref, yref, xsec, ysec) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        dx0 = opts?["dx0"] is int out1 ? out1 : 0;
        dy0 = opts?["dy0"] is int out2 ? out2 : 0;
        scale1 = opts?["scale1"] is double out3 ? out3 : 0d;
        angle1 = opts?["angle1"] is double out4 ? out4 : 0d;
        dy1 = opts?["dy1"] is double out5 ? out5 : 0d;
        dx1 = opts?["dx1"] is double out6 ? out6 : 0d;

        return finalResult;
    }

    /// <summary>
    /// First-order mosaic of two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = ref.Mosaic1(sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2, hwindow: int, harea: int, search: bool, interpolate: GObject, mblend: int);
    /// </code>
    /// </example>
    /// <param name="sec">Secondary image.</param>
    /// <param name="direction">Horizontal or vertical mosaic.</param>
    /// <param name="xr1">Position of first reference tie-point.</param>
    /// <param name="yr1">Position of first reference tie-point.</param>
    /// <param name="xs1">Position of first secondary tie-point.</param>
    /// <param name="ys1">Position of first secondary tie-point.</param>
    /// <param name="xr2">Position of second reference tie-point.</param>
    /// <param name="yr2">Position of second reference tie-point.</param>
    /// <param name="xs2">Position of second secondary tie-point.</param>
    /// <param name="ys2">Position of second secondary tie-point.</param>
    /// <param name="hwindow">Half window size.</param>
    /// <param name="harea">Half area size.</param>
    /// <param name="search">Search to improve tie-points.</param>
    /// <param name="interpolate">Interpolate pixels with this.</param>
    /// <param name="mblend">Maximum blend size.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Mosaic1(Image sec, Enums.Direction direction, int xr1, int yr1, int xs1, int ys1, int xr2, int yr2, int xs2, int ys2, int? hwindow = null, int? harea = null, bool? search = null, GObject interpolate = null, int? mblend = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(hwindow), hwindow);
        options.AddIfPresent(nameof(harea), harea);
        options.AddIfPresent(nameof(search), search);
        options.AddIfPresent(nameof(interpolate), interpolate);
        options.AddIfPresent(nameof(mblend), mblend);

        return this.Call("mosaic1", options, sec, direction, xr1, yr1, xs1, ys1, xr2, yr2, xs2, ys2) as Image;
    }

    /// <summary>
    /// Pick most-significant byte from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Msb(band: int);
    /// </code>
    /// </example>
    /// <param name="band">Band to msb.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Msb(int? band = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(band), band);

        return this.Call("msb", options) as Image;
    }

    /// <summary>
    /// Multiply two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Multiply(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Multiply(Image right)
    {
        return this.Call("multiply", right) as Image;
    }

    /// <summary>
    /// Load NIfTI volume.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Niftiload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Niftiload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("niftiload", options, filename) as Image;
    }

    /// <summary>
    /// Load NIfTI volume.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Niftiload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Niftiload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("niftiload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load NIfTI volumes.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.NiftiloadSource(source, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image NiftiloadSource(Source source, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("niftiload_source", options, source) as Image;
    }

    /// <summary>
    /// Load NIfTI volumes.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.NiftiloadStream(stream, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image NiftiloadStream(Stream stream, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = NiftiloadSource(source, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load NIfTI volumes.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.NiftiloadSource(source, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image NiftiloadSource(Source source, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("niftiload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load NIfTI volumes.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.NiftiloadStream(stream, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image NiftiloadStream(Stream stream, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = NiftiloadSource(source, out flags, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to nifti file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Niftisave(filename, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Niftisave(string filename, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("niftisave", options, filename);
    }

    /// <summary>
    /// Load an OpenEXR image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Openexrload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Openexrload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("openexrload", options, filename) as Image;
    }

    /// <summary>
    /// Load an OpenEXR image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Openexrload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Openexrload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("openexrload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load file with OpenSlide.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Openslideload(filename, level: int, autocrop: bool, associated: string, attachAssociated: bool, rgb: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="level">Load this level from the file.</param>
    /// <param name="autocrop">Crop to image bounds.</param>
    /// <param name="associated">Load this associated image.</param>
    /// <param name="attachAssociated">Attach all associated images.</param>
    /// <param name="rgb">Output RGB (not RGBA).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Openslideload(string filename, int? level = null, bool? autocrop = null, string associated = null, bool? attachAssociated = null, bool? rgb = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(autocrop), autocrop);
        options.AddIfPresent(nameof(associated), associated);
        options.AddIfPresent("attach_associated", attachAssociated);
        options.AddIfPresent(nameof(rgb), rgb);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("openslideload", options, filename) as Image;
    }

    /// <summary>
    /// Load file with OpenSlide.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Openslideload(filename, out var flags, level: int, autocrop: bool, associated: string, attachAssociated: bool, rgb: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="level">Load this level from the file.</param>
    /// <param name="autocrop">Crop to image bounds.</param>
    /// <param name="associated">Load this associated image.</param>
    /// <param name="attachAssociated">Attach all associated images.</param>
    /// <param name="rgb">Output RGB (not RGBA).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Openslideload(string filename, out Enums.ForeignFlags flags, int? level = null, bool? autocrop = null, string associated = null, bool? attachAssociated = null, bool? rgb = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(autocrop), autocrop);
        options.AddIfPresent(nameof(associated), associated);
        options.AddIfPresent("attach_associated", attachAssociated);
        options.AddIfPresent(nameof(rgb), rgb);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("openslideload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load source with OpenSlide.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.OpenslideloadSource(source, level: int, autocrop: bool, associated: string, attachAssociated: bool, rgb: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="level">Load this level from the file.</param>
    /// <param name="autocrop">Crop to image bounds.</param>
    /// <param name="associated">Load this associated image.</param>
    /// <param name="attachAssociated">Attach all associated images.</param>
    /// <param name="rgb">Output RGB (not RGBA).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image OpenslideloadSource(Source source, int? level = null, bool? autocrop = null, string associated = null, bool? attachAssociated = null, bool? rgb = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(autocrop), autocrop);
        options.AddIfPresent(nameof(associated), associated);
        options.AddIfPresent("attach_associated", attachAssociated);
        options.AddIfPresent(nameof(rgb), rgb);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("openslideload_source", options, source) as Image;
    }

    /// <summary>
    /// Load stream with OpenSlide.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.OpenslideloadStream(stream, level: int, autocrop: bool, associated: string, attachAssociated: bool, rgb: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="level">Load this level from the file.</param>
    /// <param name="autocrop">Crop to image bounds.</param>
    /// <param name="associated">Load this associated image.</param>
    /// <param name="attachAssociated">Attach all associated images.</param>
    /// <param name="rgb">Output RGB (not RGBA).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image OpenslideloadStream(Stream stream, int? level = null, bool? autocrop = null, string associated = null, bool? attachAssociated = null, bool? rgb = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = OpenslideloadSource(source, level, autocrop, associated, attachAssociated, rgb, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load source with OpenSlide.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.OpenslideloadSource(source, out var flags, level: int, autocrop: bool, associated: string, attachAssociated: bool, rgb: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="level">Load this level from the file.</param>
    /// <param name="autocrop">Crop to image bounds.</param>
    /// <param name="associated">Load this associated image.</param>
    /// <param name="attachAssociated">Attach all associated images.</param>
    /// <param name="rgb">Output RGB (not RGBA).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image OpenslideloadSource(Source source, out Enums.ForeignFlags flags, int? level = null, bool? autocrop = null, string associated = null, bool? attachAssociated = null, bool? rgb = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(autocrop), autocrop);
        options.AddIfPresent(nameof(associated), associated);
        options.AddIfPresent("attach_associated", attachAssociated);
        options.AddIfPresent(nameof(rgb), rgb);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("openslideload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load stream with OpenSlide.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.OpenslideloadStream(stream, out var flags, level: int, autocrop: bool, associated: string, attachAssociated: bool, rgb: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="level">Load this level from the file.</param>
    /// <param name="autocrop">Crop to image bounds.</param>
    /// <param name="associated">Load this associated image.</param>
    /// <param name="attachAssociated">Attach all associated images.</param>
    /// <param name="rgb">Output RGB (not RGBA).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image OpenslideloadStream(Stream stream, out Enums.ForeignFlags flags, int? level = null, bool? autocrop = null, string associated = null, bool? attachAssociated = null, bool? rgb = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = OpenslideloadSource(source, out flags, level, autocrop, associated, attachAssociated, rgb, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load PDF from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Pdfload(filename, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Pdfload(string filename, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(password), password);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("pdfload", options, filename) as Image;
    }

    /// <summary>
    /// Load PDF from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Pdfload(filename, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Pdfload(string filename, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(password), password);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("pdfload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load PDF from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PdfloadBuffer(buffer, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PdfloadBuffer(byte[] buffer, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(password), password);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("pdfload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load PDF from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PdfloadBuffer(buffer, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PdfloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(password), password);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("pdfload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load PDF from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PdfloadSource(source, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PdfloadSource(Source source, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(password), password);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("pdfload_source", options, source) as Image;
    }

    /// <summary>
    /// Load PDF from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PdfloadStream(stream, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PdfloadStream(Stream stream, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = PdfloadSource(source, page, n, dpi, scale, background, password, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load PDF from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PdfloadSource(source, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PdfloadSource(Source source, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(password), password);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("pdfload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load PDF from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PdfloadStream(stream, out var flags, page: int, n: int, dpi: double, scale: double, background: double[], password: string, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="background">Background colour.</param>
    /// <param name="password">Password to decrypt with.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PdfloadStream(Stream stream, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? dpi = null, double? scale = null, double[] background = null, string password = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = PdfloadSource(source, out flags, page, n, dpi, scale, background, password, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Find threshold for percent of pixels.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// int threshold = in.Percent(percent);
    /// </code>
    /// </example>
    /// <param name="percent">Percent of pixels.</param>
    /// <returns>A int.</returns>
    public int Percent(double percent)
    {
        return this.Call("percent", percent) is int result ? result : 0;
    }

    /// <summary>
    /// Make a perlin noise image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Perlin(width, height, cellSize: int, uchar: bool, seed: int);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="cellSize">Size of Perlin cells.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="seed">Random number seed.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Perlin(int width, int height, int? cellSize = null, bool? uchar = null, int? seed = null)
    {
        var options = new VOption();

        options.AddIfPresent("cell_size", cellSize);
        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(seed), seed);

        return Operation.Call("perlin", options, width, height) as Image;
    }

    /// <summary>
    /// Calculate phase correlation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Phasecor(in2);
    /// </code>
    /// </example>
    /// <param name="in2">Second input image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Phasecor(Image in2)
    {
        return this.Call("phasecor", in2) as Image;
    }

    /// <summary>
    /// Load png from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Pngload(filename, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Pngload(string filename, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("pngload", options, filename) as Image;
    }

    /// <summary>
    /// Load png from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Pngload(filename, out var flags, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Pngload(string filename, out Enums.ForeignFlags flags, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("pngload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load png from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PngloadBuffer(buffer, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PngloadBuffer(byte[] buffer, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("pngload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load png from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PngloadBuffer(buffer, out var flags, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PngloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("pngload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load png from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PngloadSource(source, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PngloadSource(Source source, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("pngload_source", options, source) as Image;
    }

    /// <summary>
    /// Load png from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PngloadStream(stream, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PngloadStream(Stream stream, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = PngloadSource(source, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load png from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PngloadSource(source, out var flags, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PngloadSource(Source source, out Enums.ForeignFlags flags, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("pngload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load png from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PngloadStream(stream, out var flags, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PngloadStream(Stream stream, out Enums.ForeignFlags flags, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = PngloadSource(source, out flags, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to file as PNG.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Pngsave(filename, compression: int, interlace: bool, filter: Enums.ForeignPngFilter, palette: bool, q: int, dither: double, bitdepth: int, effort: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="compression">Compression factor.</param>
    /// <param name="interlace">Interlace image.</param>
    /// <param name="filter">libspng row filter flag(s).</param>
    /// <param name="palette">Quantise to 8bpp palette.</param>
    /// <param name="q">Quantisation quality.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4, 8 or 16 bit image.</param>
    /// <param name="effort">Quantisation CPU effort.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Pngsave(string filename, int? compression = null, bool? interlace = null, Enums.ForeignPngFilter? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, int? effort = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent(nameof(filter), filter);
        options.AddIfPresent(nameof(palette), palette);
        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(dither), dither);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(effort), effort);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("pngsave", options, filename);
    }

    /// <summary>
    /// Save image to buffer as PNG.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.PngsaveBuffer(compression: int, interlace: bool, filter: Enums.ForeignPngFilter, palette: bool, q: int, dither: double, bitdepth: int, effort: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="compression">Compression factor.</param>
    /// <param name="interlace">Interlace image.</param>
    /// <param name="filter">libspng row filter flag(s).</param>
    /// <param name="palette">Quantise to 8bpp palette.</param>
    /// <param name="q">Quantisation quality.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4, 8 or 16 bit image.</param>
    /// <param name="effort">Quantisation CPU effort.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] PngsaveBuffer(int? compression = null, bool? interlace = null, Enums.ForeignPngFilter? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, int? effort = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent(nameof(filter), filter);
        options.AddIfPresent(nameof(palette), palette);
        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(dither), dither);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(effort), effort);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("pngsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image to target as PNG.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.PngsaveTarget(target, compression: int, interlace: bool, filter: Enums.ForeignPngFilter, palette: bool, q: int, dither: double, bitdepth: int, effort: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="compression">Compression factor.</param>
    /// <param name="interlace">Interlace image.</param>
    /// <param name="filter">libspng row filter flag(s).</param>
    /// <param name="palette">Quantise to 8bpp palette.</param>
    /// <param name="q">Quantisation quality.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4, 8 or 16 bit image.</param>
    /// <param name="effort">Quantisation CPU effort.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void PngsaveTarget(Target target, int? compression = null, bool? interlace = null, Enums.ForeignPngFilter? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, int? effort = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent(nameof(interlace), interlace);
        options.AddIfPresent(nameof(filter), filter);
        options.AddIfPresent(nameof(palette), palette);
        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(dither), dither);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(effort), effort);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("pngsave_target", options, target);
    }

    /// <summary>
    /// Save image to stream as PNG.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.PngsaveStream(stream, compression: int, interlace: bool, filter: Enums.ForeignPngFilter, palette: bool, q: int, dither: double, bitdepth: int, effort: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="compression">Compression factor.</param>
    /// <param name="interlace">Interlace image.</param>
    /// <param name="filter">libspng row filter flag(s).</param>
    /// <param name="palette">Quantise to 8bpp palette.</param>
    /// <param name="q">Quantisation quality.</param>
    /// <param name="dither">Amount of dithering.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4, 8 or 16 bit image.</param>
    /// <param name="effort">Quantisation CPU effort.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void PngsaveStream(Stream stream, int? compression = null, bool? interlace = null, Enums.ForeignPngFilter? filter = null, bool? palette = null, int? q = null, double? dither = null, int? bitdepth = null, int? effort = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        PngsaveTarget(target, compression, interlace, filter, palette, q, dither, bitdepth, effort, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Load ppm from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Ppmload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Ppmload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("ppmload", options, filename) as Image;
    }

    /// <summary>
    /// Load ppm from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Ppmload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Ppmload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("ppmload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load ppm from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PpmloadBuffer(buffer, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PpmloadBuffer(byte[] buffer, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("ppmload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load ppm from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PpmloadBuffer(buffer, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PpmloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("ppmload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load ppm from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PpmloadSource(source, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PpmloadSource(Source source, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("ppmload_source", options, source) as Image;
    }

    /// <summary>
    /// Load ppm from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PpmloadStream(stream, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PpmloadStream(Stream stream, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = PpmloadSource(source, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load ppm from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PpmloadSource(source, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PpmloadSource(Source source, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("ppmload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load ppm from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.PpmloadStream(stream, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image PpmloadStream(Stream stream, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = PpmloadSource(source, out flags, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to ppm file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Ppmsave(filename, format: Enums.ForeignPpmFormat, ascii: bool, bitdepth: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="format">Format to save in.</param>
    /// <param name="ascii">Save as ascii.</param>
    /// <param name="bitdepth">Set to 1 to write as a 1 bit image.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Ppmsave(string filename, Enums.ForeignPpmFormat? format = null, bool? ascii = null, int? bitdepth = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(ascii), ascii);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("ppmsave", options, filename);
    }

    /// <summary>
    /// Save to ppm.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.PpmsaveTarget(target, format: Enums.ForeignPpmFormat, ascii: bool, bitdepth: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="format">Format to save in.</param>
    /// <param name="ascii">Save as ascii.</param>
    /// <param name="bitdepth">Set to 1 to write as a 1 bit image.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void PpmsaveTarget(Target target, Enums.ForeignPpmFormat? format = null, bool? ascii = null, int? bitdepth = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(ascii), ascii);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("ppmsave_target", options, target);
    }

    /// <summary>
    /// Save to ppm.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.PpmsaveStream(stream, format: Enums.ForeignPpmFormat, ascii: bool, bitdepth: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="format">Format to save in.</param>
    /// <param name="ascii">Save as ascii.</param>
    /// <param name="bitdepth">Set to 1 to write as a 1 bit image.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void PpmsaveStream(Stream stream, Enums.ForeignPpmFormat? format = null, bool? ascii = null, int? bitdepth = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        PpmsaveTarget(target, format, ascii, bitdepth, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Premultiply image alpha.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Premultiply(maxAlpha: double);
    /// </code>
    /// </example>
    /// <param name="maxAlpha">Maximum value of alpha channel.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Premultiply(double? maxAlpha = null)
    {
        var options = new VOption();

        options.AddIfPresent("max_alpha", maxAlpha);

        return this.Call("premultiply", options) as Image;
    }

    /// <summary>
    /// Prewitt edge detector.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Prewitt();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Prewitt()
    {
        return this.Call("prewitt") as Image;
    }

    /// <summary>
    /// Find image profiles.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// var output = in.Profile();
    /// </code>
    /// </example>
    /// <returns>An array of objects.</returns>
    public object[] Profile()
    {
        return this.Call("profile") as object[];
    }

    /// <summary>
    /// Load named ICC profile.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] profile = NetVips.Image.ProfileLoad(name);
    /// </code>
    /// </example>
    /// <param name="name">Profile name.</param>
    /// <returns>An array of bytes.</returns>
    public static byte[] ProfileLoad(string name)
    {
        return Operation.Call("profile_load", name) as byte[];
    }

    /// <summary>
    /// Find image projections.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// var output = in.Project();
    /// </code>
    /// </example>
    /// <returns>An array of objects.</returns>
    public object[] Project()
    {
        return this.Call("project") as object[];
    }

    /// <summary>
    /// Resample an image with a quadratic transform.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Quadratic(coeff, interpolate: GObject);
    /// </code>
    /// </example>
    /// <param name="coeff">Coefficient matrix.</param>
    /// <param name="interpolate">Interpolate values with this.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Quadratic(Image coeff, GObject interpolate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interpolate), interpolate);

        return this.Call("quadratic", options, coeff) as Image;
    }

    /// <summary>
    /// Unpack Radiance coding to float RGB.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Rad2float();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Rad2float()
    {
        return this.Call("rad2float") as Image;
    }

    /// <summary>
    /// Load a Radiance image from a file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Radload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Radload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("radload", options, filename) as Image;
    }

    /// <summary>
    /// Load a Radiance image from a file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Radload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Radload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("radload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load rad from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.RadloadBuffer(buffer, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image RadloadBuffer(byte[] buffer, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("radload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load rad from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.RadloadBuffer(buffer, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image RadloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("radload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load rad from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.RadloadSource(source, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image RadloadSource(Source source, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("radload_source", options, source) as Image;
    }

    /// <summary>
    /// Load rad from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.RadloadStream(stream, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image RadloadStream(Stream stream, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = RadloadSource(source, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load rad from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.RadloadSource(source, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image RadloadSource(Source source, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("radload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load rad from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.RadloadStream(stream, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image RadloadStream(Stream stream, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = RadloadSource(source, out flags, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to Radiance file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Radsave(filename, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Radsave(string filename, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("radsave", options, filename);
    }

    /// <summary>
    /// Save image to Radiance buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.RadsaveBuffer(keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] RadsaveBuffer(Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("radsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image to Radiance target.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.RadsaveTarget(target, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void RadsaveTarget(Target target, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("radsave_target", options, target);
    }

    /// <summary>
    /// Save image to Radiance stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.RadsaveStream(stream, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void RadsaveStream(Stream stream, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        RadsaveTarget(target, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Rank filter.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Rank(width, height, index);
    /// </code>
    /// </example>
    /// <param name="width">Window width in pixels.</param>
    /// <param name="height">Window height in pixels.</param>
    /// <param name="index">Select pixel at index.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Rank(int width, int height, int index)
    {
        return this.Call("rank", width, height, index) as Image;
    }

    /// <summary>
    /// Load raw data from a file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Rawload(filename, width, height, bands, offset: ulong, format: Enums.BandFormat, interpretation: Enums.Interpretation, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="bands">Number of bands in image.</param>
    /// <param name="offset">Offset in bytes from start of file.</param>
    /// <param name="format">Pixel format in image.</param>
    /// <param name="interpretation">Pixel interpretation.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Rawload(string filename, int width, int height, int bands, ulong? offset = null, Enums.BandFormat? format = null, Enums.Interpretation? interpretation = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(offset), offset);
        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(interpretation), interpretation);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("rawload", options, filename, width, height, bands) as Image;
    }

    /// <summary>
    /// Load raw data from a file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Rawload(filename, width, height, bands, out var flags, offset: ulong, format: Enums.BandFormat, interpretation: Enums.Interpretation, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="bands">Number of bands in image.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="offset">Offset in bytes from start of file.</param>
    /// <param name="format">Pixel format in image.</param>
    /// <param name="interpretation">Pixel interpretation.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Rawload(string filename, int width, int height, int bands, out Enums.ForeignFlags flags, ulong? offset = null, Enums.BandFormat? format = null, Enums.Interpretation? interpretation = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(offset), offset);
        options.AddIfPresent(nameof(format), format);
        options.AddIfPresent(nameof(interpretation), interpretation);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("rawload", options, filename, width, height, bands) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Save image to raw file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Rawsave(filename, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Rawsave(string filename, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("rawsave", options, filename);
    }

    /// <summary>
    /// Write raw image to buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.RawsaveBuffer(keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] RawsaveBuffer(Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("rawsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Write raw image to target.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.RawsaveTarget(target, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void RawsaveTarget(Target target, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("rawsave_target", options, target);
    }

    /// <summary>
    /// Write raw image to stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.RawsaveStream(stream, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void RawsaveStream(Stream stream, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        RawsaveTarget(target, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Linear recombination with matrix.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Recomb(m);
    /// </code>
    /// </example>
    /// <param name="m">Matrix of coefficients.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Recomb(Image m)
    {
        return this.Call("recomb", m) as Image;
    }

    /// <summary>
    /// Reduce an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Reduce(hshrink, vshrink, kernel: Enums.Kernel, gap: double);
    /// </code>
    /// </example>
    /// <param name="hshrink">Horizontal shrink factor.</param>
    /// <param name="vshrink">Vertical shrink factor.</param>
    /// <param name="kernel">Resampling kernel.</param>
    /// <param name="gap">Reducing gap.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Reduce(double hshrink, double vshrink, Enums.Kernel? kernel = null, double? gap = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(kernel), kernel);
        options.AddIfPresent(nameof(gap), gap);

        return this.Call("reduce", options, hshrink, vshrink) as Image;
    }

    /// <summary>
    /// Shrink an image horizontally.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Reduceh(hshrink, kernel: Enums.Kernel, gap: double);
    /// </code>
    /// </example>
    /// <param name="hshrink">Horizontal shrink factor.</param>
    /// <param name="kernel">Resampling kernel.</param>
    /// <param name="gap">Reducing gap.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Reduceh(double hshrink, Enums.Kernel? kernel = null, double? gap = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(kernel), kernel);
        options.AddIfPresent(nameof(gap), gap);

        return this.Call("reduceh", options, hshrink) as Image;
    }

    /// <summary>
    /// Shrink an image vertically.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Reducev(vshrink, kernel: Enums.Kernel, gap: double);
    /// </code>
    /// </example>
    /// <param name="vshrink">Vertical shrink factor.</param>
    /// <param name="kernel">Resampling kernel.</param>
    /// <param name="gap">Reducing gap.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Reducev(double vshrink, Enums.Kernel? kernel = null, double? gap = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(kernel), kernel);
        options.AddIfPresent(nameof(gap), gap);

        return this.Call("reducev", options, vshrink) as Image;
    }

    /// <summary>
    /// Relational operation on two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Relational(right, relational);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <param name="relational">Relational to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Relational(Image right, Enums.OperationRelational relational)
    {
        return this.Call("relational", right, relational) as Image;
    }

    /// <summary>
    /// Relational operations against a constant.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.RelationalConst(relational, c);
    /// </code>
    /// </example>
    /// <param name="relational">Relational to perform.</param>
    /// <param name="c">Array of constants.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image RelationalConst(Enums.OperationRelational relational, double[] c)
    {
        return this.Call("relational_const", relational, c) as Image;
    }

    /// <summary>
    /// Remainder after integer division of two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Remainder(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Remainder(Image right)
    {
        return this.Call("remainder", right) as Image;
    }

    /// <summary>
    /// Remainder after integer division of an image and a constant.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.RemainderConst(c);
    /// </code>
    /// </example>
    /// <param name="c">Array of constants.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image RemainderConst(double[] c)
    {
        return this.Call("remainder_const", c) as Image;
    }

    /// <summary>
    /// Rebuild an mosaiced image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Remosaic(oldStr, newStr);
    /// </code>
    /// </example>
    /// <param name="oldStr">Search for this string.</param>
    /// <param name="newStr">And swap for this string.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Remosaic(string oldStr, string newStr)
    {
        return this.Call("remosaic", oldStr, newStr) as Image;
    }

    /// <summary>
    /// Replicate an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Replicate(across, down);
    /// </code>
    /// </example>
    /// <param name="across">Repeat this many times horizontally.</param>
    /// <param name="down">Repeat this many times vertically.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Replicate(int across, int down)
    {
        return this.Call("replicate", across, down) as Image;
    }

    /// <summary>
    /// Resize an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Resize(scale, kernel: Enums.Kernel, gap: double, vscale: double);
    /// </code>
    /// </example>
    /// <param name="scale">Scale image by this factor.</param>
    /// <param name="kernel">Resampling kernel.</param>
    /// <param name="gap">Reducing gap.</param>
    /// <param name="vscale">Vertical scale image by this factor.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Resize(double scale, Enums.Kernel? kernel = null, double? gap = null, double? vscale = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(kernel), kernel);
        options.AddIfPresent(nameof(gap), gap);
        options.AddIfPresent(nameof(vscale), vscale);

        return this.Call("resize", options, scale) as Image;
    }

    /// <summary>
    /// Rotate an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Rot(angle);
    /// </code>
    /// </example>
    /// <param name="angle">Angle to rotate image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Rot(Enums.Angle angle)
    {
        return this.Call("rot", angle) as Image;
    }

    /// <summary>
    /// Rotate an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Rot45(angle: Enums.Angle45);
    /// </code>
    /// </example>
    /// <param name="angle">Angle to rotate image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Rot45(Enums.Angle45? angle = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(angle), angle);

        return this.Call("rot45", options) as Image;
    }

    /// <summary>
    /// Rotate an image by a number of degrees.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Rotate(angle, interpolate: GObject, background: double[], odx: double, ody: double, idx: double, idy: double);
    /// </code>
    /// </example>
    /// <param name="angle">Rotate clockwise by this many degrees.</param>
    /// <param name="interpolate">Interpolate pixels with this.</param>
    /// <param name="background">Background value.</param>
    /// <param name="odx">Horizontal output displacement.</param>
    /// <param name="ody">Vertical output displacement.</param>
    /// <param name="idx">Horizontal input displacement.</param>
    /// <param name="idy">Vertical input displacement.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Rotate(double angle, GObject interpolate = null, double[] background = null, double? odx = null, double? ody = null, double? idx = null, double? idy = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interpolate), interpolate);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(odx), odx);
        options.AddIfPresent(nameof(ody), ody);
        options.AddIfPresent(nameof(idx), idx);
        options.AddIfPresent(nameof(idy), idy);

        return this.Call("rotate", options, angle) as Image;
    }

    /// <summary>
    /// Perform a round function on an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Round(round);
    /// </code>
    /// </example>
    /// <param name="round">Rounding operation to perform.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Round(Enums.OperationRound round)
    {
        return this.Call("round", round) as Image;
    }

    /// <summary>
    /// Scharr edge detector.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Scharr();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Scharr()
    {
        return this.Call("scharr") as Image;
    }

    /// <summary>
    /// Convert scRGB to BW.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.ScRGB2BW(depth: int);
    /// </code>
    /// </example>
    /// <param name="depth">Output device space depth in bits.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image ScRGB2BW(int? depth = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(depth), depth);

        return this.Call("scRGB2BW", options) as Image;
    }

    /// <summary>
    /// Convert scRGB to sRGB.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.ScRGB2sRGB(depth: int);
    /// </code>
    /// </example>
    /// <param name="depth">Output device space depth in bits.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image ScRGB2sRGB(int? depth = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(depth), depth);

        return this.Call("scRGB2sRGB", options) as Image;
    }

    /// <summary>
    /// Transform scRGB to XYZ.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.ScRGB2XYZ();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image ScRGB2XYZ()
    {
        return this.Call("scRGB2XYZ") as Image;
    }

    /// <summary>
    /// Create an SDF image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Sdf(width, height, shape, r: double, a: double[], b: double[], corners: double[]);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="shape">SDF shape to create.</param>
    /// <param name="r">Radius.</param>
    /// <param name="a">Point a.</param>
    /// <param name="b">Point b.</param>
    /// <param name="corners">Corner radii.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Sdf(int width, int height, Enums.SdfShape shape, double? r = null, double[] a = null, double[] b = null, double[] corners = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(r), r);
        options.AddIfPresent(nameof(a), a);
        options.AddIfPresent(nameof(b), b);
        options.AddIfPresent(nameof(corners), corners);

        return Operation.Call("sdf", options, width, height, shape) as Image;
    }

    /// <summary>
    /// Check sequential access.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Sequential(tileHeight: int);
    /// </code>
    /// </example>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Sequential(int? tileHeight = null)
    {
        var options = new VOption();

        options.AddIfPresent("tile_height", tileHeight);

        return this.Call("sequential", options) as Image;
    }

    /// <summary>
    /// Unsharp masking for print.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Sharpen(sigma: double, x1: double, y2: double, y3: double, m1: double, m2: double);
    /// </code>
    /// </example>
    /// <param name="sigma">Sigma of Gaussian.</param>
    /// <param name="x1">Flat/jaggy threshold.</param>
    /// <param name="y2">Maximum brightening.</param>
    /// <param name="y3">Maximum darkening.</param>
    /// <param name="m1">Slope for flat areas.</param>
    /// <param name="m2">Slope for jaggy areas.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Sharpen(double? sigma = null, double? x1 = null, double? y2 = null, double? y3 = null, double? m1 = null, double? m2 = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(sigma), sigma);
        options.AddIfPresent(nameof(x1), x1);
        options.AddIfPresent(nameof(y2), y2);
        options.AddIfPresent(nameof(y3), y3);
        options.AddIfPresent(nameof(m1), m1);
        options.AddIfPresent(nameof(m2), m2);

        return this.Call("sharpen", options) as Image;
    }

    /// <summary>
    /// Shrink an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Shrink(hshrink, vshrink, ceil: bool);
    /// </code>
    /// </example>
    /// <param name="hshrink">Horizontal shrink factor.</param>
    /// <param name="vshrink">Vertical shrink factor.</param>
    /// <param name="ceil">Round-up output dimensions.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Shrink(double hshrink, double vshrink, bool? ceil = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(ceil), ceil);

        return this.Call("shrink", options, hshrink, vshrink) as Image;
    }

    /// <summary>
    /// Shrink an image horizontally.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Shrinkh(hshrink, ceil: bool);
    /// </code>
    /// </example>
    /// <param name="hshrink">Horizontal shrink factor.</param>
    /// <param name="ceil">Round-up output dimensions.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Shrinkh(int hshrink, bool? ceil = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(ceil), ceil);

        return this.Call("shrinkh", options, hshrink) as Image;
    }

    /// <summary>
    /// Shrink an image vertically.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Shrinkv(vshrink, ceil: bool);
    /// </code>
    /// </example>
    /// <param name="vshrink">Vertical shrink factor.</param>
    /// <param name="ceil">Round-up output dimensions.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Shrinkv(int vshrink, bool? ceil = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(ceil), ceil);

        return this.Call("shrinkv", options, vshrink) as Image;
    }

    /// <summary>
    /// Unit vector of pixel.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Sign();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Sign()
    {
        return this.Call("sign") as Image;
    }

    /// <summary>
    /// Similarity transform of an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Similarity(scale: double, angle: double, interpolate: GObject, background: double[], odx: double, ody: double, idx: double, idy: double);
    /// </code>
    /// </example>
    /// <param name="scale">Scale by this factor.</param>
    /// <param name="angle">Rotate clockwise by this many degrees.</param>
    /// <param name="interpolate">Interpolate pixels with this.</param>
    /// <param name="background">Background value.</param>
    /// <param name="odx">Horizontal output displacement.</param>
    /// <param name="ody">Vertical output displacement.</param>
    /// <param name="idx">Horizontal input displacement.</param>
    /// <param name="idy">Vertical input displacement.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Similarity(double? scale = null, double? angle = null, GObject interpolate = null, double[] background = null, double? odx = null, double? ody = null, double? idx = null, double? idy = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(angle), angle);
        options.AddIfPresent(nameof(interpolate), interpolate);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent(nameof(odx), odx);
        options.AddIfPresent(nameof(ody), ody);
        options.AddIfPresent(nameof(idx), idx);
        options.AddIfPresent(nameof(idy), idy);

        return this.Call("similarity", options) as Image;
    }

    /// <summary>
    /// Make a 2D sine wave.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Sines(width, height, uchar: bool, hfreq: double, vfreq: double);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <param name="hfreq">Horizontal spatial frequency.</param>
    /// <param name="vfreq">Vertical spatial frequency.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Sines(int width, int height, bool? uchar = null, double? hfreq = null, double? vfreq = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);
        options.AddIfPresent(nameof(hfreq), hfreq);
        options.AddIfPresent(nameof(vfreq), vfreq);

        return Operation.Call("sines", options, width, height) as Image;
    }

    /// <summary>
    /// Extract an area from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = input.Smartcrop(width, height, interesting: Enums.Interesting, premultiplied: bool);
    /// </code>
    /// </example>
    /// <param name="width">Width of extract area.</param>
    /// <param name="height">Height of extract area.</param>
    /// <param name="interesting">How to measure interestingness.</param>
    /// <param name="premultiplied">Input image already has premultiplied alpha.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Smartcrop(int width, int height, Enums.Interesting? interesting = null, bool? premultiplied = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interesting), interesting);
        options.AddIfPresent(nameof(premultiplied), premultiplied);

        return this.Call("smartcrop", options, width, height) as Image;
    }

    /// <summary>
    /// Extract an area from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = input.Smartcrop(width, height, out var attentionX, interesting: Enums.Interesting, premultiplied: bool);
    /// </code>
    /// </example>
    /// <param name="width">Width of extract area.</param>
    /// <param name="height">Height of extract area.</param>
    /// <param name="attentionX">Horizontal position of attention centre.</param>
    /// <param name="interesting">How to measure interestingness.</param>
    /// <param name="premultiplied">Input image already has premultiplied alpha.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Smartcrop(int width, int height, out int attentionX, Enums.Interesting? interesting = null, bool? premultiplied = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interesting), interesting);
        options.AddIfPresent(nameof(premultiplied), premultiplied);

        options.Add("attention_x", true);

        var results = this.Call("smartcrop", options, width, height) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        attentionX = opts?["attention_x"] is int out1 ? out1 : 0;

        return finalResult;
    }

    /// <summary>
    /// Extract an area from an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = input.Smartcrop(width, height, out var attentionX, out var attentionY, interesting: Enums.Interesting, premultiplied: bool);
    /// </code>
    /// </example>
    /// <param name="width">Width of extract area.</param>
    /// <param name="height">Height of extract area.</param>
    /// <param name="attentionX">Horizontal position of attention centre.</param>
    /// <param name="attentionY">Vertical position of attention centre.</param>
    /// <param name="interesting">How to measure interestingness.</param>
    /// <param name="premultiplied">Input image already has premultiplied alpha.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Smartcrop(int width, int height, out int attentionX, out int attentionY, Enums.Interesting? interesting = null, bool? premultiplied = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(interesting), interesting);
        options.AddIfPresent(nameof(premultiplied), premultiplied);

        options.Add("attention_x", true);
        options.Add("attention_y", true);

        var results = this.Call("smartcrop", options, width, height) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        attentionX = opts?["attention_x"] is int out1 ? out1 : 0;
        attentionY = opts?["attention_y"] is int out2 ? out2 : 0;

        return finalResult;
    }

    /// <summary>
    /// Sobel edge detector.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Sobel();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Sobel()
    {
        return this.Call("sobel") as Image;
    }

    /// <summary>
    /// Spatial correlation.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Spcor(@ref);
    /// </code>
    /// </example>
    /// <param name="ref">Input reference image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Spcor(Image @ref)
    {
        return this.Call("spcor", @ref) as Image;
    }

    /// <summary>
    /// Make displayable power spectrum.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Spectrum();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Spectrum()
    {
        return this.Call("spectrum") as Image;
    }

    /// <summary>
    /// Transform sRGB to HSV.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.SRGB2HSV();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image SRGB2HSV()
    {
        return this.Call("sRGB2HSV") as Image;
    }

    /// <summary>
    /// Convert an sRGB image to scRGB.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.SRGB2scRGB();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image SRGB2scRGB()
    {
        return this.Call("sRGB2scRGB") as Image;
    }

    /// <summary>
    /// Find many image stats.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Stats();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Stats()
    {
        return this.Call("stats") as Image;
    }

    /// <summary>
    /// Statistical difference.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Stdif(width, height, s0: double, b: double, m0: double, a: double);
    /// </code>
    /// </example>
    /// <param name="width">Window width in pixels.</param>
    /// <param name="height">Window height in pixels.</param>
    /// <param name="s0">New deviation.</param>
    /// <param name="b">Weight of new deviation.</param>
    /// <param name="m0">New mean.</param>
    /// <param name="a">Weight of new mean.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Stdif(int width, int height, double? s0 = null, double? b = null, double? m0 = null, double? a = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(s0), s0);
        options.AddIfPresent(nameof(b), b);
        options.AddIfPresent(nameof(m0), m0);
        options.AddIfPresent(nameof(a), a);

        return this.Call("stdif", options, width, height) as Image;
    }

    /// <summary>
    /// Subsample an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = input.Subsample(xfac, yfac, point: bool);
    /// </code>
    /// </example>
    /// <param name="xfac">Horizontal subsample factor.</param>
    /// <param name="yfac">Vertical subsample factor.</param>
    /// <param name="point">Point sample.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Subsample(int xfac, int yfac, bool? point = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(point), point);

        return this.Call("subsample", options, xfac, yfac) as Image;
    }

    /// <summary>
    /// Subtract two images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = left.Subtract(right);
    /// </code>
    /// </example>
    /// <param name="right">Right-hand image argument.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Subtract(Image right)
    {
        return this.Call("subtract", right) as Image;
    }

    /// <summary>
    /// Sum an array of images.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Sum(@in);
    /// </code>
    /// </example>
    /// <param name="in">Array of input images.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Sum(params Image[] @in)
    {
        return Operation.Call("sum", new object[] { @in }) as Image;
    }

    /// <summary>
    /// Load SVG with rsvg.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Svgload(filename, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Svgload(string filename, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(stylesheet), stylesheet);
        options.AddIfPresent("high_bitdepth", highBitdepth);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("svgload", options, filename) as Image;
    }

    /// <summary>
    /// Load SVG with rsvg.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Svgload(filename, out var flags, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Svgload(string filename, out Enums.ForeignFlags flags, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(stylesheet), stylesheet);
        options.AddIfPresent("high_bitdepth", highBitdepth);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("svgload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load SVG with rsvg.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.SvgloadBuffer(buffer, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image SvgloadBuffer(byte[] buffer, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(stylesheet), stylesheet);
        options.AddIfPresent("high_bitdepth", highBitdepth);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("svgload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load SVG with rsvg.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.SvgloadBuffer(buffer, out var flags, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image SvgloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(stylesheet), stylesheet);
        options.AddIfPresent("high_bitdepth", highBitdepth);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("svgload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load svg from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.SvgloadSource(source, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image SvgloadSource(Source source, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(stylesheet), stylesheet);
        options.AddIfPresent("high_bitdepth", highBitdepth);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("svgload_source", options, source) as Image;
    }

    /// <summary>
    /// Load svg from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.SvgloadStream(stream, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image SvgloadStream(Stream stream, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = SvgloadSource(source, dpi, scale, unlimited, stylesheet, highBitdepth, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load svg from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.SvgloadSource(source, out var flags, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image SvgloadSource(Source source, out Enums.ForeignFlags flags, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(stylesheet), stylesheet);
        options.AddIfPresent("high_bitdepth", highBitdepth);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("svgload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load svg from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.SvgloadStream(stream, out var flags, dpi: double, scale: double, unlimited: bool, stylesheet: string, highBitdepth: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="dpi">Render at this DPI.</param>
    /// <param name="scale">Scale output by this factor.</param>
    /// <param name="unlimited">Allow SVG of any size.</param>
    /// <param name="stylesheet">Custom CSS.</param>
    /// <param name="highBitdepth">Enable scRGB 128-bit output (32-bit per channel).</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image SvgloadStream(Stream stream, out Enums.ForeignFlags flags, double? dpi = null, double? scale = null, bool? unlimited = null, string stylesheet = null, bool? highBitdepth = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = SvgloadSource(source, out flags, dpi, scale, unlimited, stylesheet, highBitdepth, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Find the index of the first non-zero pixel in tests.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Switch(tests);
    /// </code>
    /// </example>
    /// <param name="tests">Table of images to test.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Switch(params Image[] tests)
    {
        return Operation.Call("switch", new object[] { tests }) as Image;
    }

    /// <summary>
    /// Run an external command.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// NetVips.Image.System(cmdFormat, @in: Image[], outFormat: string, inFormat: string);
    /// </code>
    /// </example>
    /// <param name="cmdFormat">Command to run.</param>
    /// <param name="in">Array of input images.</param>
    /// <param name="outFormat">Format for output filename.</param>
    /// <param name="inFormat">Format for input filename.</param>
    public static void System(string cmdFormat, Image[] @in = null, string outFormat = null, string inFormat = null)
    {
        var options = new VOption();

        options.AddIfPresent("in", @in);
        options.AddIfPresent("out_format", outFormat);
        options.AddIfPresent("in_format", inFormat);

        Operation.Call("system", options, cmdFormat);
    }

    /// <summary>
    /// Run an external command.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// NetVips.Image.System(cmdFormat, out var @out, @in: Image[], outFormat: string, inFormat: string);
    /// </code>
    /// </example>
    /// <param name="cmdFormat">Command to run.</param>
    /// <param name="out">Output image.</param>
    /// <param name="in">Array of input images.</param>
    /// <param name="outFormat">Format for output filename.</param>
    /// <param name="inFormat">Format for input filename.</param>
    public static void System(string cmdFormat, out Image @out, Image[] @in = null, string outFormat = null, string inFormat = null)
    {
        var options = new VOption();

        options.AddIfPresent("in", @in);
        options.AddIfPresent("out_format", outFormat);
        options.AddIfPresent("in_format", inFormat);

        options.Add("out", true);

        var results = Operation.Call("system", options, cmdFormat) as object[];

        var opts = results?[1] as VOption;
        @out = opts?["out"] as Image;
    }

    /// <summary>
    /// Run an external command.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// NetVips.Image.System(cmdFormat, out var @out, out var log, @in: Image[], outFormat: string, inFormat: string);
    /// </code>
    /// </example>
    /// <param name="cmdFormat">Command to run.</param>
    /// <param name="out">Output image.</param>
    /// <param name="log">Command log.</param>
    /// <param name="in">Array of input images.</param>
    /// <param name="outFormat">Format for output filename.</param>
    /// <param name="inFormat">Format for input filename.</param>
    public static void System(string cmdFormat, out Image @out, out string log, Image[] @in = null, string outFormat = null, string inFormat = null)
    {
        var options = new VOption();

        options.AddIfPresent("in", @in);
        options.AddIfPresent("out_format", outFormat);
        options.AddIfPresent("in_format", inFormat);

        options.Add("out", true);
        options.Add("log", true);

        var results = Operation.Call("system", options, cmdFormat) as object[];

        var opts = results?[1] as VOption;
        @out = opts?["out"] as Image;
        log = opts?["log"] is string out2 ? out2 : null;
    }

    /// <summary>
    /// Make a text image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Text(text, font: string, width: int, height: int, align: Enums.Align, justify: bool, dpi: int, spacing: int, fontfile: string, rgba: bool, wrap: Enums.TextWrap);
    /// </code>
    /// </example>
    /// <param name="text">Text to render.</param>
    /// <param name="font">Font to render with.</param>
    /// <param name="width">Maximum image width in pixels.</param>
    /// <param name="height">Maximum image height in pixels.</param>
    /// <param name="align">Align on the low, centre or high edge.</param>
    /// <param name="justify">Justify lines.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="spacing">Line spacing.</param>
    /// <param name="fontfile">Load this font file.</param>
    /// <param name="rgba">Enable RGBA output.</param>
    /// <param name="wrap">Wrap lines on word or character boundaries.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Text(string text, string font = null, int? width = null, int? height = null, Enums.Align? align = null, bool? justify = null, int? dpi = null, int? spacing = null, string fontfile = null, bool? rgba = null, Enums.TextWrap? wrap = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(font), font);
        options.AddIfPresent(nameof(width), width);
        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(align), align);
        options.AddIfPresent(nameof(justify), justify);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(spacing), spacing);
        options.AddIfPresent(nameof(fontfile), fontfile);
        options.AddIfPresent(nameof(rgba), rgba);
        options.AddIfPresent(nameof(wrap), wrap);

        return Operation.Call("text", options, text) as Image;
    }

    /// <summary>
    /// Make a text image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Text(text, out var autofitDpi, font: string, width: int, height: int, align: Enums.Align, justify: bool, dpi: int, spacing: int, fontfile: string, rgba: bool, wrap: Enums.TextWrap);
    /// </code>
    /// </example>
    /// <param name="text">Text to render.</param>
    /// <param name="autofitDpi">DPI selected by autofit.</param>
    /// <param name="font">Font to render with.</param>
    /// <param name="width">Maximum image width in pixels.</param>
    /// <param name="height">Maximum image height in pixels.</param>
    /// <param name="align">Align on the low, centre or high edge.</param>
    /// <param name="justify">Justify lines.</param>
    /// <param name="dpi">DPI to render at.</param>
    /// <param name="spacing">Line spacing.</param>
    /// <param name="fontfile">Load this font file.</param>
    /// <param name="rgba">Enable RGBA output.</param>
    /// <param name="wrap">Wrap lines on word or character boundaries.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Text(string text, out int autofitDpi, string font = null, int? width = null, int? height = null, Enums.Align? align = null, bool? justify = null, int? dpi = null, int? spacing = null, string fontfile = null, bool? rgba = null, Enums.TextWrap? wrap = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(font), font);
        options.AddIfPresent(nameof(width), width);
        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(align), align);
        options.AddIfPresent(nameof(justify), justify);
        options.AddIfPresent(nameof(dpi), dpi);
        options.AddIfPresent(nameof(spacing), spacing);
        options.AddIfPresent(nameof(fontfile), fontfile);
        options.AddIfPresent(nameof(rgba), rgba);
        options.AddIfPresent(nameof(wrap), wrap);

        options.Add("autofit_dpi", true);

        var results = Operation.Call("text", options, text) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        autofitDpi = opts?["autofit_dpi"] is int out1 ? out1 : 0;

        return finalResult;
    }

    /// <summary>
    /// Generate thumbnail from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Thumbnail(filename, width, height: int, size: Enums.Size, noRotate: bool, crop: Enums.Interesting, linear: bool, inputProfile: string, outputProfile: string, intent: Enums.Intent, failOn: Enums.FailOn);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to read from.</param>
    /// <param name="width">Size to this width.</param>
    /// <param name="height">Size to this height.</param>
    /// <param name="size">Only upsize, only downsize, or both.</param>
    /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
    /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
    /// <param name="linear">Reduce in linear light.</param>
    /// <param name="inputProfile">Fallback input profile.</param>
    /// <param name="outputProfile">Fallback output profile.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Thumbnail(string filename, int width, int? height = null, Enums.Size? size = null, bool? noRotate = null, Enums.Interesting? crop = null, bool? linear = null, string inputProfile = null, string outputProfile = null, Enums.Intent? intent = null, Enums.FailOn? failOn = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(size), size);
        options.AddIfPresent("no_rotate", noRotate);
        options.AddIfPresent(nameof(crop), crop);
        options.AddIfPresent(nameof(linear), linear);
        options.AddIfPresent("input_profile", inputProfile);
        options.AddIfPresent("output_profile", outputProfile);
        options.AddIfPresent(nameof(intent), intent);
        options.AddFailOn(failOn);

        return Operation.Call("thumbnail", options, filename, width) as Image;
    }

    /// <summary>
    /// Generate thumbnail from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.ThumbnailBuffer(buffer, width, optionString: string, height: int, size: Enums.Size, noRotate: bool, crop: Enums.Interesting, linear: bool, inputProfile: string, outputProfile: string, intent: Enums.Intent, failOn: Enums.FailOn);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="width">Size to this width.</param>
    /// <param name="optionString">Options that are passed on to the underlying loader.</param>
    /// <param name="height">Size to this height.</param>
    /// <param name="size">Only upsize, only downsize, or both.</param>
    /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
    /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
    /// <param name="linear">Reduce in linear light.</param>
    /// <param name="inputProfile">Fallback input profile.</param>
    /// <param name="outputProfile">Fallback output profile.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image ThumbnailBuffer(byte[] buffer, int width, string optionString = null, int? height = null, Enums.Size? size = null, bool? noRotate = null, Enums.Interesting? crop = null, bool? linear = null, string inputProfile = null, string outputProfile = null, Enums.Intent? intent = null, Enums.FailOn? failOn = null)
    {
        var options = new VOption();

        options.AddIfPresent("option_string", optionString);
        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(size), size);
        options.AddIfPresent("no_rotate", noRotate);
        options.AddIfPresent(nameof(crop), crop);
        options.AddIfPresent(nameof(linear), linear);
        options.AddIfPresent("input_profile", inputProfile);
        options.AddIfPresent("output_profile", outputProfile);
        options.AddIfPresent(nameof(intent), intent);
        options.AddFailOn(failOn);

        return Operation.Call("thumbnail_buffer", options, buffer, width) as Image;
    }

    /// <summary>
    /// Generate thumbnail from image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.ThumbnailImage(width, height: int, size: Enums.Size, noRotate: bool, crop: Enums.Interesting, linear: bool, inputProfile: string, outputProfile: string, intent: Enums.Intent, failOn: Enums.FailOn);
    /// </code>
    /// </example>
    /// <param name="width">Size to this width.</param>
    /// <param name="height">Size to this height.</param>
    /// <param name="size">Only upsize, only downsize, or both.</param>
    /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
    /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
    /// <param name="linear">Reduce in linear light.</param>
    /// <param name="inputProfile">Fallback input profile.</param>
    /// <param name="outputProfile">Fallback output profile.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image ThumbnailImage(int width, int? height = null, Enums.Size? size = null, bool? noRotate = null, Enums.Interesting? crop = null, bool? linear = null, string inputProfile = null, string outputProfile = null, Enums.Intent? intent = null, Enums.FailOn? failOn = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(size), size);
        options.AddIfPresent("no_rotate", noRotate);
        options.AddIfPresent(nameof(crop), crop);
        options.AddIfPresent(nameof(linear), linear);
        options.AddIfPresent("input_profile", inputProfile);
        options.AddIfPresent("output_profile", outputProfile);
        options.AddIfPresent(nameof(intent), intent);
        options.AddFailOn(failOn);

        return this.Call("thumbnail_image", options, width) as Image;
    }

    /// <summary>
    /// Generate thumbnail from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.ThumbnailSource(source, width, optionString: string, height: int, size: Enums.Size, noRotate: bool, crop: Enums.Interesting, linear: bool, inputProfile: string, outputProfile: string, intent: Enums.Intent, failOn: Enums.FailOn);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="width">Size to this width.</param>
    /// <param name="optionString">Options that are passed on to the underlying loader.</param>
    /// <param name="height">Size to this height.</param>
    /// <param name="size">Only upsize, only downsize, or both.</param>
    /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
    /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
    /// <param name="linear">Reduce in linear light.</param>
    /// <param name="inputProfile">Fallback input profile.</param>
    /// <param name="outputProfile">Fallback output profile.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image ThumbnailSource(Source source, int width, string optionString = null, int? height = null, Enums.Size? size = null, bool? noRotate = null, Enums.Interesting? crop = null, bool? linear = null, string inputProfile = null, string outputProfile = null, Enums.Intent? intent = null, Enums.FailOn? failOn = null)
    {
        var options = new VOption();

        options.AddIfPresent("option_string", optionString);
        options.AddIfPresent(nameof(height), height);
        options.AddIfPresent(nameof(size), size);
        options.AddIfPresent("no_rotate", noRotate);
        options.AddIfPresent(nameof(crop), crop);
        options.AddIfPresent(nameof(linear), linear);
        options.AddIfPresent("input_profile", inputProfile);
        options.AddIfPresent("output_profile", outputProfile);
        options.AddIfPresent(nameof(intent), intent);
        options.AddFailOn(failOn);

        return Operation.Call("thumbnail_source", options, source, width) as Image;
    }

    /// <summary>
    /// Generate thumbnail from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.ThumbnailStream(stream, width, optionString: string, height: int, size: Enums.Size, noRotate: bool, crop: Enums.Interesting, linear: bool, inputProfile: string, outputProfile: string, intent: Enums.Intent, failOn: Enums.FailOn);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="width">Size to this width.</param>
    /// <param name="optionString">Options that are passed on to the underlying loader.</param>
    /// <param name="height">Size to this height.</param>
    /// <param name="size">Only upsize, only downsize, or both.</param>
    /// <param name="noRotate">Don't use orientation tags to rotate image upright.</param>
    /// <param name="crop">Reduce to fill target rectangle, then crop.</param>
    /// <param name="linear">Reduce in linear light.</param>
    /// <param name="inputProfile">Fallback input profile.</param>
    /// <param name="outputProfile">Fallback output profile.</param>
    /// <param name="intent">Rendering intent.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image ThumbnailStream(Stream stream, int width, string optionString = null, int? height = null, Enums.Size? size = null, bool? noRotate = null, Enums.Interesting? crop = null, bool? linear = null, string inputProfile = null, string outputProfile = null, Enums.Intent? intent = null, Enums.FailOn? failOn = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = ThumbnailSource(source, width, optionString, height, size, noRotate, crop, linear, inputProfile, outputProfile, intent, failOn);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load tiff from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Tiffload(filename, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Tiffload(string filename, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("tiffload", options, filename) as Image;
    }

    /// <summary>
    /// Load tiff from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Tiffload(filename, out var flags, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Tiffload(string filename, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("tiffload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load tiff from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.TiffloadBuffer(buffer, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image TiffloadBuffer(byte[] buffer, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("tiffload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load tiff from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.TiffloadBuffer(buffer, out var flags, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image TiffloadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("tiffload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load tiff from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.TiffloadSource(source, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image TiffloadSource(Source source, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("tiffload_source", options, source) as Image;
    }

    /// <summary>
    /// Load tiff from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.TiffloadStream(stream, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image TiffloadStream(Stream stream, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = TiffloadSource(source, page, n, autorotate, subifd, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load tiff from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.TiffloadSource(source, out var flags, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image TiffloadSource(Source source, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(autorotate), autorotate);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(unlimited), unlimited);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("tiffload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load tiff from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.TiffloadStream(stream, out var flags, page: int, n: int, autorotate: bool, subifd: int, unlimited: bool, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="autorotate">Rotate image using orientation tag.</param>
    /// <param name="subifd">Subifd index.</param>
    /// <param name="unlimited">Remove all denial of service limits.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image TiffloadStream(Stream stream, out Enums.ForeignFlags flags, int? page = null, int? n = null, bool? autorotate = null, int? subifd = null, bool? unlimited = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = TiffloadSource(source, out flags, page, n, autorotate, subifd, unlimited, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to tiff file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Tiffsave(filename, compression: Enums.ForeignTiffCompression, q: int, predictor: Enums.ForeignTiffPredictor, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, bitdepth: int, resunit: Enums.ForeignTiffResunit, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: Enums.RegionShrink, level: int, lossless: bool, depth: Enums.ForeignDzDepth, subifd: bool, premultiply: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="compression">Compression for this file.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="predictor">Compression prediction.</param>
    /// <param name="tile">Write a tiled tiff.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="pyramid">Write a pyramidal tiff.</param>
    /// <param name="miniswhite">Use 0 for white in 1-bit images.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
    /// <param name="resunit">Resolution unit.</param>
    /// <param name="xres">Horizontal resolution in pixels/mm.</param>
    /// <param name="yres">Vertical resolution in pixels/mm.</param>
    /// <param name="bigtiff">Write a bigtiff image.</param>
    /// <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="level">Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level.</param>
    /// <param name="lossless">Enable WEBP lossless mode.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="subifd">Save pyr layers as sub-IFDs.</param>
    /// <param name="premultiply">Save with premultiplied alpha.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Tiffsave(string filename, Enums.ForeignTiffCompression? compression = null, int? q = null, Enums.ForeignTiffPredictor? predictor = null, bool? tile = null, int? tileWidth = null, int? tileHeight = null, bool? pyramid = null, bool? miniswhite = null, int? bitdepth = null, Enums.ForeignTiffResunit? resunit = null, double? xres = null, double? yres = null, bool? bigtiff = null, bool? properties = null, Enums.RegionShrink? regionShrink = null, int? level = null, bool? lossless = null, Enums.ForeignDzDepth? depth = null, bool? subifd = null, bool? premultiply = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(predictor), predictor);
        options.AddIfPresent(nameof(tile), tile);
        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(pyramid), pyramid);
        options.AddIfPresent(nameof(miniswhite), miniswhite);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(resunit), resunit);
        options.AddIfPresent(nameof(xres), xres);
        options.AddIfPresent(nameof(yres), yres);
        options.AddIfPresent(nameof(bigtiff), bigtiff);
        options.AddIfPresent(nameof(properties), properties);
        options.AddIfPresent("region_shrink", regionShrink);
        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(depth), depth);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(premultiply), premultiply);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("tiffsave", options, filename);
    }

    /// <summary>
    /// Save image to tiff buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.TiffsaveBuffer(compression: Enums.ForeignTiffCompression, q: int, predictor: Enums.ForeignTiffPredictor, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, bitdepth: int, resunit: Enums.ForeignTiffResunit, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: Enums.RegionShrink, level: int, lossless: bool, depth: Enums.ForeignDzDepth, subifd: bool, premultiply: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="compression">Compression for this file.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="predictor">Compression prediction.</param>
    /// <param name="tile">Write a tiled tiff.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="pyramid">Write a pyramidal tiff.</param>
    /// <param name="miniswhite">Use 0 for white in 1-bit images.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
    /// <param name="resunit">Resolution unit.</param>
    /// <param name="xres">Horizontal resolution in pixels/mm.</param>
    /// <param name="yres">Vertical resolution in pixels/mm.</param>
    /// <param name="bigtiff">Write a bigtiff image.</param>
    /// <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="level">Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level.</param>
    /// <param name="lossless">Enable WEBP lossless mode.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="subifd">Save pyr layers as sub-IFDs.</param>
    /// <param name="premultiply">Save with premultiplied alpha.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] TiffsaveBuffer(Enums.ForeignTiffCompression? compression = null, int? q = null, Enums.ForeignTiffPredictor? predictor = null, bool? tile = null, int? tileWidth = null, int? tileHeight = null, bool? pyramid = null, bool? miniswhite = null, int? bitdepth = null, Enums.ForeignTiffResunit? resunit = null, double? xres = null, double? yres = null, bool? bigtiff = null, bool? properties = null, Enums.RegionShrink? regionShrink = null, int? level = null, bool? lossless = null, Enums.ForeignDzDepth? depth = null, bool? subifd = null, bool? premultiply = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(predictor), predictor);
        options.AddIfPresent(nameof(tile), tile);
        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(pyramid), pyramid);
        options.AddIfPresent(nameof(miniswhite), miniswhite);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(resunit), resunit);
        options.AddIfPresent(nameof(xres), xres);
        options.AddIfPresent(nameof(yres), yres);
        options.AddIfPresent(nameof(bigtiff), bigtiff);
        options.AddIfPresent(nameof(properties), properties);
        options.AddIfPresent("region_shrink", regionShrink);
        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(depth), depth);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(premultiply), premultiply);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("tiffsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image to tiff target.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.TiffsaveTarget(target, compression: Enums.ForeignTiffCompression, q: int, predictor: Enums.ForeignTiffPredictor, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, bitdepth: int, resunit: Enums.ForeignTiffResunit, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: Enums.RegionShrink, level: int, lossless: bool, depth: Enums.ForeignDzDepth, subifd: bool, premultiply: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="compression">Compression for this file.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="predictor">Compression prediction.</param>
    /// <param name="tile">Write a tiled tiff.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="pyramid">Write a pyramidal tiff.</param>
    /// <param name="miniswhite">Use 0 for white in 1-bit images.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
    /// <param name="resunit">Resolution unit.</param>
    /// <param name="xres">Horizontal resolution in pixels/mm.</param>
    /// <param name="yres">Vertical resolution in pixels/mm.</param>
    /// <param name="bigtiff">Write a bigtiff image.</param>
    /// <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="level">Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level.</param>
    /// <param name="lossless">Enable WEBP lossless mode.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="subifd">Save pyr layers as sub-IFDs.</param>
    /// <param name="premultiply">Save with premultiplied alpha.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void TiffsaveTarget(Target target, Enums.ForeignTiffCompression? compression = null, int? q = null, Enums.ForeignTiffPredictor? predictor = null, bool? tile = null, int? tileWidth = null, int? tileHeight = null, bool? pyramid = null, bool? miniswhite = null, int? bitdepth = null, Enums.ForeignTiffResunit? resunit = null, double? xres = null, double? yres = null, bool? bigtiff = null, bool? properties = null, Enums.RegionShrink? regionShrink = null, int? level = null, bool? lossless = null, Enums.ForeignDzDepth? depth = null, bool? subifd = null, bool? premultiply = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(compression), compression);
        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(predictor), predictor);
        options.AddIfPresent(nameof(tile), tile);
        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent(nameof(pyramid), pyramid);
        options.AddIfPresent(nameof(miniswhite), miniswhite);
        options.AddIfPresent(nameof(bitdepth), bitdepth);
        options.AddIfPresent(nameof(resunit), resunit);
        options.AddIfPresent(nameof(xres), xres);
        options.AddIfPresent(nameof(yres), yres);
        options.AddIfPresent(nameof(bigtiff), bigtiff);
        options.AddIfPresent(nameof(properties), properties);
        options.AddIfPresent("region_shrink", regionShrink);
        options.AddIfPresent(nameof(level), level);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(depth), depth);
        options.AddIfPresent(nameof(subifd), subifd);
        options.AddIfPresent(nameof(premultiply), premultiply);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("tiffsave_target", options, target);
    }

    /// <summary>
    /// Save image to tiff stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.TiffsaveStream(stream, compression: Enums.ForeignTiffCompression, q: int, predictor: Enums.ForeignTiffPredictor, tile: bool, tileWidth: int, tileHeight: int, pyramid: bool, miniswhite: bool, bitdepth: int, resunit: Enums.ForeignTiffResunit, xres: double, yres: double, bigtiff: bool, properties: bool, regionShrink: Enums.RegionShrink, level: int, lossless: bool, depth: Enums.ForeignDzDepth, subifd: bool, premultiply: bool, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="compression">Compression for this file.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="predictor">Compression prediction.</param>
    /// <param name="tile">Write a tiled tiff.</param>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="pyramid">Write a pyramidal tiff.</param>
    /// <param name="miniswhite">Use 0 for white in 1-bit images.</param>
    /// <param name="bitdepth">Write as a 1, 2, 4 or 8 bit image.</param>
    /// <param name="resunit">Resolution unit.</param>
    /// <param name="xres">Horizontal resolution in pixels/mm.</param>
    /// <param name="yres">Vertical resolution in pixels/mm.</param>
    /// <param name="bigtiff">Write a bigtiff image.</param>
    /// <param name="properties">Write a properties document to IMAGEDESCRIPTION.</param>
    /// <param name="regionShrink">Method to shrink regions.</param>
    /// <param name="level">Deflate (1-9, default 6) or ZSTD (1-22, default 9) compression level.</param>
    /// <param name="lossless">Enable WEBP lossless mode.</param>
    /// <param name="depth">Pyramid depth.</param>
    /// <param name="subifd">Save pyr layers as sub-IFDs.</param>
    /// <param name="premultiply">Save with premultiplied alpha.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void TiffsaveStream(Stream stream, Enums.ForeignTiffCompression? compression = null, int? q = null, Enums.ForeignTiffPredictor? predictor = null, bool? tile = null, int? tileWidth = null, int? tileHeight = null, bool? pyramid = null, bool? miniswhite = null, int? bitdepth = null, Enums.ForeignTiffResunit? resunit = null, double? xres = null, double? yres = null, bool? bigtiff = null, bool? properties = null, Enums.RegionShrink? regionShrink = null, int? level = null, bool? lossless = null, Enums.ForeignDzDepth? depth = null, bool? subifd = null, bool? premultiply = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        TiffsaveTarget(target, compression, q, predictor, tile, tileWidth, tileHeight, pyramid, miniswhite, bitdepth, resunit, xres, yres, bigtiff, properties, regionShrink, level, lossless, depth, subifd, premultiply, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Cache an image as a set of tiles.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Tilecache(tileWidth: int, tileHeight: int, maxTiles: int, access: Enums.Access, threaded: bool, persistent: bool);
    /// </code>
    /// </example>
    /// <param name="tileWidth">Tile width in pixels.</param>
    /// <param name="tileHeight">Tile height in pixels.</param>
    /// <param name="maxTiles">Maximum number of tiles to cache.</param>
    /// <param name="access">Expected access pattern.</param>
    /// <param name="threaded">Allow threaded access.</param>
    /// <param name="persistent">Keep cache between evaluations.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Tilecache(int? tileWidth = null, int? tileHeight = null, int? maxTiles = null, Enums.Access? access = null, bool? threaded = null, bool? persistent = null)
    {
        var options = new VOption();

        options.AddIfPresent("tile_width", tileWidth);
        options.AddIfPresent("tile_height", tileHeight);
        options.AddIfPresent("max_tiles", maxTiles);
        options.AddIfPresent(nameof(access), access);
        options.AddIfPresent(nameof(threaded), threaded);
        options.AddIfPresent(nameof(persistent), persistent);

        return this.Call("tilecache", options) as Image;
    }

    /// <summary>
    /// Build a look-up table.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Tonelut(inMax: int, outMax: int, lb: double, lw: double, ps: double, pm: double, ph: double, s: double, m: double, h: double);
    /// </code>
    /// </example>
    /// <param name="inMax">Size of LUT to build.</param>
    /// <param name="outMax">Maximum value in output LUT.</param>
    /// <param name="lb">Lowest value in output.</param>
    /// <param name="lw">Highest value in output.</param>
    /// <param name="ps">Position of shadow.</param>
    /// <param name="pm">Position of mid-tones.</param>
    /// <param name="ph">Position of highlights.</param>
    /// <param name="s">Adjust shadows by this much.</param>
    /// <param name="m">Adjust mid-tones by this much.</param>
    /// <param name="h">Adjust highlights by this much.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Tonelut(int? inMax = null, int? outMax = null, double? lb = null, double? lw = null, double? ps = null, double? pm = null, double? ph = null, double? s = null, double? m = null, double? h = null)
    {
        var options = new VOption();

        options.AddIfPresent("in_max", inMax);
        options.AddIfPresent("out_max", outMax);
        options.AddIfPresent("Lb", lb);
        options.AddIfPresent("Lw", lw);
        options.AddIfPresent("Ps", ps);
        options.AddIfPresent("Pm", pm);
        options.AddIfPresent("Ph", ph);
        options.AddIfPresent("S", s);
        options.AddIfPresent("M", m);
        options.AddIfPresent("H", h);

        return Operation.Call("tonelut", options) as Image;
    }

    /// <summary>
    /// Transpose3d an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Transpose3d(pageHeight: int);
    /// </code>
    /// </example>
    /// <param name="pageHeight">Height of each input page.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Transpose3d(int? pageHeight = null)
    {
        var options = new VOption();

        options.AddIfPresent("page_height", pageHeight);

        return this.Call("transpose3d", options) as Image;
    }

    /// <summary>
    /// Unpremultiply image alpha.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Unpremultiply(maxAlpha: double, alphaBand: int);
    /// </code>
    /// </example>
    /// <param name="maxAlpha">Maximum value of alpha channel.</param>
    /// <param name="alphaBand">Unpremultiply with this alpha.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Unpremultiply(double? maxAlpha = null, int? alphaBand = null)
    {
        var options = new VOption();

        options.AddIfPresent("max_alpha", maxAlpha);
        options.AddIfPresent("alpha_band", alphaBand);

        return this.Call("unpremultiply", options) as Image;
    }

    /// <summary>
    /// Load vips from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Vipsload(filename, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Vipsload(string filename, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("vipsload", options, filename) as Image;
    }

    /// <summary>
    /// Load vips from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Vipsload(filename, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Vipsload(string filename, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("vipsload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load vips from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.VipsloadSource(source, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image VipsloadSource(Source source, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("vipsload_source", options, source) as Image;
    }

    /// <summary>
    /// Load vips from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.VipsloadStream(stream, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image VipsloadStream(Stream stream, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = VipsloadSource(source, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load vips from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.VipsloadSource(source, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image VipsloadSource(Source source, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("vipsload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load vips from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.VipsloadStream(stream, out var flags, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image VipsloadStream(Stream stream, out Enums.ForeignFlags flags, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = VipsloadSource(source, out flags, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save image to file in vips format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Vipssave(filename, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Vipssave(string filename, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("vipssave", options, filename);
    }

    /// <summary>
    /// Save image to target in vips format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.VipssaveTarget(target, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void VipssaveTarget(Target target, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("vipssave_target", options, target);
    }

    /// <summary>
    /// Save image to stream in vips format.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.VipssaveStream(stream, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void VipssaveStream(Stream stream, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        VipssaveTarget(target, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Load webp from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Webpload(filename, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Webpload(string filename, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("webpload", options, filename) as Image;
    }

    /// <summary>
    /// Load webp from file.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Webpload(filename, out var flags, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Webpload(string filename, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("webpload", options, filename) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load webp from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.WebploadBuffer(buffer, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image WebploadBuffer(byte[] buffer, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("webpload_buffer", options, buffer) as Image;
    }

    /// <summary>
    /// Load webp from buffer.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.WebploadBuffer(buffer, out var flags, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="buffer">Buffer to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image WebploadBuffer(byte[] buffer, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("webpload_buffer", options, buffer) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load webp from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.WebploadSource(source, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image WebploadSource(Source source, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        return Operation.Call("webpload_source", options, source) as Image;
    }

    /// <summary>
    /// Load webp from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.WebploadStream(stream, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image WebploadStream(Stream stream, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = WebploadSource(source, page, n, scale, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Load webp from source.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.WebploadSource(source, out var flags, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="source">Source to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image WebploadSource(Source source, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(page), page);
        options.AddIfPresent(nameof(n), n);
        options.AddIfPresent(nameof(scale), scale);
        options.AddIfPresent(nameof(memory), memory);
        options.AddIfPresent(nameof(access), access);
        options.AddFailOn(failOn);
        options.AddIfPresent(nameof(revalidate), revalidate);

        options.Add("flags", true);

        var results = Operation.Call("webpload_source", options, source) as object[];
        var finalResult = results?[0] as Image;
        var opts = results?[1] as VOption;
        flags = (Enums.ForeignFlags)opts?["flags"];

        return finalResult;
    }

    /// <summary>
    /// Load webp from stream.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.WebploadStream(stream, out var flags, page: int, n: int, scale: double, memory: bool, access: Enums.Access, failOn: Enums.FailOn, revalidate: bool);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to load from.</param>
    /// <param name="flags">Flags for this file.</param>
    /// <param name="page">First page to load.</param>
    /// <param name="n">Number of pages to load, -1 for all.</param>
    /// <param name="scale">Factor to scale by.</param>
    /// <param name="memory">Force open via memory.</param>
    /// <param name="access">Required access pattern for this file.</param>
    /// <param name="failOn">Error level to fail on.</param>
    /// <param name="revalidate">Don't use a cached result for this operation.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image WebploadStream(Stream stream, out Enums.ForeignFlags flags, int? page = null, int? n = null, double? scale = null, bool? memory = null, Enums.Access? access = null, Enums.FailOn? failOn = null, bool? revalidate = null)
    {
        var source = SourceStream.NewFromStream(stream);
        var image = WebploadSource(source, out flags, page, n, scale, memory, access, failOn, revalidate);

        image.OnPostClose += () => source.Dispose();

        return image;
    }

    /// <summary>
    /// Save as WebP.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.Webpsave(filename, q: int, lossless: bool, preset: Enums.ForeignWebpPreset, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, effort: int, targetSize: int, mixed: bool, smartDeblock: bool, passes: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="filename">Filename to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="preset">Preset for lossy compression.</param>
    /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
    /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
    /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
    /// <param name="minSize">Optimise for minimum size.</param>
    /// <param name="kmin">Minimum number of frames between key frames.</param>
    /// <param name="kmax">Maximum number of frames between key frames.</param>
    /// <param name="effort">Level of CPU effort to reduce file size.</param>
    /// <param name="targetSize">Desired target size in bytes.</param>
    /// <param name="mixed">Allow mixed encoding (might reduce file size).</param>
    /// <param name="smartDeblock">Enable auto-adjusting of the deblocking filter.</param>
    /// <param name="passes">Number of entropy-analysis passes (in [1..10]).</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void Webpsave(string filename, int? q = null, bool? lossless = null, Enums.ForeignWebpPreset? preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? effort = null, int? targetSize = null, bool? mixed = null, bool? smartDeblock = null, int? passes = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(preset), preset);
        options.AddIfPresent("smart_subsample", smartSubsample);
        options.AddIfPresent("near_lossless", nearLossless);
        options.AddIfPresent("alpha_q", alphaQ);
        options.AddIfPresent("min_size", minSize);
        options.AddIfPresent(nameof(kmin), kmin);
        options.AddIfPresent(nameof(kmax), kmax);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("target_size", targetSize);
        options.AddIfPresent(nameof(mixed), mixed);
        options.AddIfPresent("smart_deblock", smartDeblock);
        options.AddIfPresent(nameof(passes), passes);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("webpsave", options, filename);
    }

    /// <summary>
    /// Save as WebP.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// byte[] buffer = in.WebpsaveBuffer(q: int, lossless: bool, preset: Enums.ForeignWebpPreset, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, effort: int, targetSize: int, mixed: bool, smartDeblock: bool, passes: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="q">Q factor.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="preset">Preset for lossy compression.</param>
    /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
    /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
    /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
    /// <param name="minSize">Optimise for minimum size.</param>
    /// <param name="kmin">Minimum number of frames between key frames.</param>
    /// <param name="kmax">Maximum number of frames between key frames.</param>
    /// <param name="effort">Level of CPU effort to reduce file size.</param>
    /// <param name="targetSize">Desired target size in bytes.</param>
    /// <param name="mixed">Allow mixed encoding (might reduce file size).</param>
    /// <param name="smartDeblock">Enable auto-adjusting of the deblocking filter.</param>
    /// <param name="passes">Number of entropy-analysis passes (in [1..10]).</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    /// <returns>An array of bytes.</returns>
    public byte[] WebpsaveBuffer(int? q = null, bool? lossless = null, Enums.ForeignWebpPreset? preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? effort = null, int? targetSize = null, bool? mixed = null, bool? smartDeblock = null, int? passes = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(preset), preset);
        options.AddIfPresent("smart_subsample", smartSubsample);
        options.AddIfPresent("near_lossless", nearLossless);
        options.AddIfPresent("alpha_q", alphaQ);
        options.AddIfPresent("min_size", minSize);
        options.AddIfPresent(nameof(kmin), kmin);
        options.AddIfPresent(nameof(kmax), kmax);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("target_size", targetSize);
        options.AddIfPresent(nameof(mixed), mixed);
        options.AddIfPresent("smart_deblock", smartDeblock);
        options.AddIfPresent(nameof(passes), passes);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        return this.Call("webpsave_buffer", options) as byte[];
    }

    /// <summary>
    /// Save image to webp mime.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.WebpsaveMime(q: int, lossless: bool, preset: Enums.ForeignWebpPreset, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, effort: int, targetSize: int, mixed: bool, smartDeblock: bool, passes: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="q">Q factor.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="preset">Preset for lossy compression.</param>
    /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
    /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
    /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
    /// <param name="minSize">Optimise for minimum size.</param>
    /// <param name="kmin">Minimum number of frames between key frames.</param>
    /// <param name="kmax">Maximum number of frames between key frames.</param>
    /// <param name="effort">Level of CPU effort to reduce file size.</param>
    /// <param name="targetSize">Desired target size in bytes.</param>
    /// <param name="mixed">Allow mixed encoding (might reduce file size).</param>
    /// <param name="smartDeblock">Enable auto-adjusting of the deblocking filter.</param>
    /// <param name="passes">Number of entropy-analysis passes (in [1..10]).</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void WebpsaveMime(int? q = null, bool? lossless = null, Enums.ForeignWebpPreset? preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? effort = null, int? targetSize = null, bool? mixed = null, bool? smartDeblock = null, int? passes = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(preset), preset);
        options.AddIfPresent("smart_subsample", smartSubsample);
        options.AddIfPresent("near_lossless", nearLossless);
        options.AddIfPresent("alpha_q", alphaQ);
        options.AddIfPresent("min_size", minSize);
        options.AddIfPresent(nameof(kmin), kmin);
        options.AddIfPresent(nameof(kmax), kmax);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("target_size", targetSize);
        options.AddIfPresent(nameof(mixed), mixed);
        options.AddIfPresent("smart_deblock", smartDeblock);
        options.AddIfPresent(nameof(passes), passes);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("webpsave_mime", options);
    }

    /// <summary>
    /// Save as WebP.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.WebpsaveTarget(target, q: int, lossless: bool, preset: Enums.ForeignWebpPreset, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, effort: int, targetSize: int, mixed: bool, smartDeblock: bool, passes: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="target">Target to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="preset">Preset for lossy compression.</param>
    /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
    /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
    /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
    /// <param name="minSize">Optimise for minimum size.</param>
    /// <param name="kmin">Minimum number of frames between key frames.</param>
    /// <param name="kmax">Maximum number of frames between key frames.</param>
    /// <param name="effort">Level of CPU effort to reduce file size.</param>
    /// <param name="targetSize">Desired target size in bytes.</param>
    /// <param name="mixed">Allow mixed encoding (might reduce file size).</param>
    /// <param name="smartDeblock">Enable auto-adjusting of the deblocking filter.</param>
    /// <param name="passes">Number of entropy-analysis passes (in [1..10]).</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void WebpsaveTarget(Target target, int? q = null, bool? lossless = null, Enums.ForeignWebpPreset? preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? effort = null, int? targetSize = null, bool? mixed = null, bool? smartDeblock = null, int? passes = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        var options = new VOption();

        options.AddIfPresent("Q", q);
        options.AddIfPresent(nameof(lossless), lossless);
        options.AddIfPresent(nameof(preset), preset);
        options.AddIfPresent("smart_subsample", smartSubsample);
        options.AddIfPresent("near_lossless", nearLossless);
        options.AddIfPresent("alpha_q", alphaQ);
        options.AddIfPresent("min_size", minSize);
        options.AddIfPresent(nameof(kmin), kmin);
        options.AddIfPresent(nameof(kmax), kmax);
        options.AddIfPresent(nameof(effort), effort);
        options.AddIfPresent("target_size", targetSize);
        options.AddIfPresent(nameof(mixed), mixed);
        options.AddIfPresent("smart_deblock", smartDeblock);
        options.AddIfPresent(nameof(passes), passes);
        options.AddForeignKeep(keep);
        options.AddIfPresent(nameof(background), background);
        options.AddIfPresent("page_height", pageHeight);
        options.AddIfPresent(nameof(profile), profile);

        this.Call("webpsave_target", options, target);
    }

    /// <summary>
    /// Save as WebP.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// in.WebpsaveStream(stream, q: int, lossless: bool, preset: Enums.ForeignWebpPreset, smartSubsample: bool, nearLossless: bool, alphaQ: int, minSize: bool, kmin: int, kmax: int, effort: int, targetSize: int, mixed: bool, smartDeblock: bool, passes: int, keep: Enums.ForeignKeep, background: double[], pageHeight: int, profile: string);
    /// </code>
    /// </example>
    /// <param name="stream">Stream to save to.</param>
    /// <param name="q">Q factor.</param>
    /// <param name="lossless">Enable lossless compression.</param>
    /// <param name="preset">Preset for lossy compression.</param>
    /// <param name="smartSubsample">Enable high quality chroma subsampling.</param>
    /// <param name="nearLossless">Enable preprocessing in lossless mode (uses Q).</param>
    /// <param name="alphaQ">Change alpha plane fidelity for lossy compression.</param>
    /// <param name="minSize">Optimise for minimum size.</param>
    /// <param name="kmin">Minimum number of frames between key frames.</param>
    /// <param name="kmax">Maximum number of frames between key frames.</param>
    /// <param name="effort">Level of CPU effort to reduce file size.</param>
    /// <param name="targetSize">Desired target size in bytes.</param>
    /// <param name="mixed">Allow mixed encoding (might reduce file size).</param>
    /// <param name="smartDeblock">Enable auto-adjusting of the deblocking filter.</param>
    /// <param name="passes">Number of entropy-analysis passes (in [1..10]).</param>
    /// <param name="keep">Which metadata to retain.</param>
    /// <param name="background">Background value.</param>
    /// <param name="pageHeight">Set page height for multipage save.</param>
    /// <param name="profile">Filename of ICC profile to embed.</param>
    public void WebpsaveStream(Stream stream, int? q = null, bool? lossless = null, Enums.ForeignWebpPreset? preset = null, bool? smartSubsample = null, bool? nearLossless = null, int? alphaQ = null, bool? minSize = null, int? kmin = null, int? kmax = null, int? effort = null, int? targetSize = null, bool? mixed = null, bool? smartDeblock = null, int? passes = null, Enums.ForeignKeep? keep = null, double[] background = null, int? pageHeight = null, string profile = null)
    {
        using var target = TargetStream.NewFromStream(stream);
        WebpsaveTarget(target, q, lossless, preset, smartSubsample, nearLossless, alphaQ, minSize, kmin, kmax, effort, targetSize, mixed, smartDeblock, passes, keep, background, pageHeight, profile);
    }

    /// <summary>
    /// Make a worley noise image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Worley(width, height, cellSize: int, seed: int);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="cellSize">Size of Worley cells.</param>
    /// <param name="seed">Random number seed.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Worley(int width, int height, int? cellSize = null, int? seed = null)
    {
        var options = new VOption();

        options.AddIfPresent("cell_size", cellSize);
        options.AddIfPresent(nameof(seed), seed);

        return Operation.Call("worley", options, width, height) as Image;
    }

    /// <summary>
    /// Wrap image origin.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Wrap(x: int, y: int);
    /// </code>
    /// </example>
    /// <param name="x">Left edge of input in output.</param>
    /// <param name="y">Top edge of input in output.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Wrap(int? x = null, int? y = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(x), x);
        options.AddIfPresent(nameof(y), y);

        return this.Call("wrap", options) as Image;
    }

    /// <summary>
    /// Make an image where pixel values are coordinates.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Xyz(width, height, csize: int, dsize: int, esize: int);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="csize">Size of third dimension.</param>
    /// <param name="dsize">Size of fourth dimension.</param>
    /// <param name="esize">Size of fifth dimension.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Xyz(int width, int height, int? csize = null, int? dsize = null, int? esize = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(csize), csize);
        options.AddIfPresent(nameof(dsize), dsize);
        options.AddIfPresent(nameof(esize), esize);

        return Operation.Call("xyz", options, width, height) as Image;
    }

    /// <summary>
    /// Transform XYZ to CMYK.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.XYZ2CMYK();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image XYZ2CMYK()
    {
        return this.Call("XYZ2CMYK") as Image;
    }

    /// <summary>
    /// Transform XYZ to Lab.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.XYZ2Lab(temp: double[]);
    /// </code>
    /// </example>
    /// <param name="temp">Colour temperature.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image XYZ2Lab(double[] temp = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(temp), temp);

        return this.Call("XYZ2Lab", options) as Image;
    }

    /// <summary>
    /// Transform XYZ to scRGB.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.XYZ2scRGB();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image XYZ2scRGB()
    {
        return this.Call("XYZ2scRGB") as Image;
    }

    /// <summary>
    /// Transform XYZ to Yxy.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.XYZ2Yxy();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image XYZ2Yxy()
    {
        return this.Call("XYZ2Yxy") as Image;
    }

    /// <summary>
    /// Transform Yxy to XYZ.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = in.Yxy2XYZ();
    /// </code>
    /// </example>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Yxy2XYZ()
    {
        return this.Call("Yxy2XYZ") as Image;
    }

    /// <summary>
    /// Make a zone plate.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = NetVips.Image.Zone(width, height, uchar: bool);
    /// </code>
    /// </example>
    /// <param name="width">Image width in pixels.</param>
    /// <param name="height">Image height in pixels.</param>
    /// <param name="uchar">Output an unsigned char image.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public static Image Zone(int width, int height, bool? uchar = null)
    {
        var options = new VOption();

        options.AddIfPresent(nameof(uchar), uchar);

        return Operation.Call("zone", options, width, height) as Image;
    }

    /// <summary>
    /// Zoom an image.
    /// </summary>
    /// <example>
    /// <code language="lang-csharp">
    /// using Image @out = input.Zoom(xfac, yfac);
    /// </code>
    /// </example>
    /// <param name="xfac">Horizontal zoom factor.</param>
    /// <param name="yfac">Vertical zoom factor.</param>
    /// <returns>A new <see cref="Image"/>.</returns>
    public Image Zoom(int xfac, int yfac)
    {
        return this.Call("zoom", xfac, yfac) as Image;
    }

    #endregion

    #region auto-generated properties

    /// <summary>
    /// Image width in pixels
    /// </summary>
    public int Width => (int)Get("width");

    /// <summary>
    /// Image height in pixels
    /// </summary>
    public int Height => (int)Get("height");

    /// <summary>
    /// Number of bands in image
    /// </summary>
    public int Bands => (int)Get("bands");

    /// <summary>
    /// Pixel format in image
    /// </summary>
    public Enums.BandFormat Format => (Enums.BandFormat)Get("format");

    /// <summary>
    /// Pixel coding
    /// </summary>
    public Enums.Coding Coding => (Enums.Coding)Get("coding");

    /// <summary>
    /// Pixel interpretation
    /// </summary>
    public Enums.Interpretation Interpretation => (Enums.Interpretation)Get("interpretation");

    /// <summary>
    /// Horizontal offset of origin
    /// </summary>
    public int Xoffset => (int)Get("xoffset");

    /// <summary>
    /// Vertical offset of origin
    /// </summary>
    public int Yoffset => (int)Get("yoffset");

    /// <summary>
    /// Horizontal resolution in pixels/mm
    /// </summary>
    public double Xres => (double)Get("xres");

    /// <summary>
    /// Vertical resolution in pixels/mm
    /// </summary>
    public double Yres => (double)Get("yres");

    /// <summary>
    /// Image filename
    /// </summary>
    public string Filename => (string)Get("filename");

    #endregion
}