<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Getting Started with NetVips </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Getting Started with NetVips ">
    <meta name="generator" content="docfx 2.42.0.0">
    
    <link rel="shortcut icon" href="../images/favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../images/logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="getting-started-with-netvips">Getting Started with NetVips</h1>

<p>See the main libvips site for an introduction to the underlying library. These
notes introduce the .NET binding.</p>
<p><a href="https://libvips.github.io/libvips">https://libvips.github.io/libvips</a></p>
<h2 id="example">Example</h2>
<p>This example loads a file, boosts the green channel, sharpens the image,
and saves it back to disc again:</p>
<pre><code class="lang-csharp">using NetVips;

var image = Image.NewFromFile(&quot;some-image.jpg&quot;, access: Enums.Access.Sequential);

image *= new[] {1, 2, 1};

var mask = Image.NewFromArray(new[,]
{
    {-1, -1, -1},
    {-1, 16, -1},
    {-1, -1, -1}
}, scale: 8);
image = image.Conv(mask, precision: Enums.Precision.Integer);

image.WriteToFile(&quot;x.jpg&quot;);
</code></pre>
<p>Reading this example line by line, we have:</p>
<pre><code class="lang-csharp">var image = Image.NewFromFile(&quot;some-image.jpg&quot;, access: Enums.Access.Sequential);
</code></pre>
<p><a class="xref" href="../api/NetVips.Image.html#NetVips_Image_NewFromFile_"><code>NewFromFile</code></a> can load any image file supported by libvips. In
this example, we will be accessing pixels top-to-bottom as we sweep through
the image reading and writing, so <code>sequential</code> access mode is best for us.</p>
<p>The default mode is <code>random</code> which allows for full random access to image
pixels, but is slower and needs more memory. See <a class="xref" href="../api/NetVips.Enums.Access.html"><code>Enums.Access</code></a>
for full details on the various modes available.</p>
<p>You can also load formatted images from memory, create images that
wrap C-style memory arrays held as an byte array, or make images from
constants.</p>
<p>The next line:</p>
<pre><code class="lang-csharp">image *= new[] {1, 2, 1};
</code></pre>
<p>Multiplying the image by an array constant uses one array element for each
image band. This line assumes that the input image has three bands and will
double the middle band. For RGB images, that's doubling green.</p>
<p>There are the usual range of arithmetic operator overloads.</p>
<p>Next we have:</p>
<pre><code class="lang-csharp">var mask = Image.NewFromArray(new[,]
{
    {-1, -1, -1},
    {-1, 16, -1},
    {-1, -1, -1}
}, scale: 8);
image = image.Conv(mask, precision: Enums.Precision.Integer);
</code></pre>
<p><a class="xref" href="../api/NetVips.Image.html#NetVips_Image_NewFromArray_"><code>NewFromArray</code></a> creates an image from an array constant. The
scale is the amount to divide the image by after integer convolution.</p>
<p>See the libvips API docs for <a href="http://libvips.github.io/libvips/API/current/libvips-convolution.html#vips-conv"><code>vips_conv()</code></a>
(the operation invoked by <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Conv_"><code>Conv</code></a>) for details on the convolution operator. By
default, it computes with a float mask, but <code>integer</code> is fine for this case,
and is much faster.</p>
<p>Finally:</p>
<pre><code class="lang-csharp">image.WriteToFile(&quot;x.jpg&quot;);
</code></pre>
<p><a class="xref" href="../api/NetVips.Image.html#NetVips_Image_WriteToFile_"><code>WriteToFile</code></a> writes an image back to the filesystem. It can
write any format supported by vips: the file type is set from the filename
suffix. You can also write formatted images to memory, or dump
image data to a C-style array in an byte array.</p>
<h2 id="metadata-and-attributes">Metadata and attributes</h2>
<p>NetVips has a <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Get_"><code>Get</code></a> method to look up unknown names in libvips.
To make it a bit easier, common properties that libvips keeps for images are accessible by C# properties,
see <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Width_"><code>.Width</code></a> and friends.</p>
<p>As well as the core properties, you can read and write the metadata
that libvips keeps for images with <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Get_"><code>Get</code></a> and
friends. For example:</p>
<pre><code class="lang-csharp">var image = Image.NewFromFile(&quot;some-image.jpg&quot;);
var iptcString = image.Get(&quot;iptc-data&quot;);
var exifDateString = image.Get(&quot;exif-ifd0-DateTime&quot;);
</code></pre>
<p>Use <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_GetFields_"><code>GetFields()</code></a> to get a list of all the field names you can use with
<a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Get_"><code>Get</code></a>.</p>
<p>libvips caches and shares images behind your back, so you can't change an image
unless you are certain you have the only reference to it.</p>
<p>Set image properties, like <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Xres_"><code>.Xres</code></a> with <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Copy_"><code>Copy</code></a>. For
example:</p>
<pre><code class="lang-csharp">var newImage = image.Copy(xres: 12, yres: 13);
</code></pre>
<p>Now <code>newImage</code> is a private clone of <code>image</code> with <code>xres</code> and <code>yres</code>
changed.</p>
<p>Set image metadata with <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Set_"><code>Set</code></a>. Use <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Copy_"><code>Copy</code></a> to make
a private copy of the image first, for example:</p>
<pre><code class="lang-csharp">var newImage = image.Copy();
newImage.Set(&quot;icc-profile-data&quot;, newProfile);
</code></pre>
<p>Now <code>newImage</code> is a clone of <code>image</code> with a new ICC profile attached to
it.</p>
<h2 id="calling-libvips-operations">Calling libvips operations</h2>
<p>All libvips operations were generated automatically to a PascalCase method in NetVips.
For example, the libvips operation <code>add</code>, which appears in C as
<a href="http://libvips.github.io/libvips/API/current/libvips-arithmetic.html#vips-add"><code>vips_add()</code></a>,
appears in C# as <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Add_"><code>Add</code></a> method.</p>
<p>By taking advantage of nullable types (which allows you to omit any parameters in any position),
we are able to call libvips operations that have optional arguments.</p>
<p>Some libvips operations have optional output arguments, for such operations we generated
the corresponding method overloads. For example, <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Min_"><code>Min</code></a>, the vips operation
that searches an image for the minimum value, has a large number of optional arguments.
You can use it to find the minimum value like this:</p>
<pre><code class="lang-csharp">var minValue = image.Min();
</code></pre>
<p>You can ask it to return the position of the minimum with <code>out var xPos</code> and <code>out var yPos</code>:</p>
<pre><code class="lang-csharp">var minValue = image.Min(out var xPos, out var yPos);
</code></pre>
<p>Now <code>xPos</code> and <code>yPos</code> will have the coordinates of the minimum value.
There's actually a convenience method for this, <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_MinPos_"><code>MinPos</code></a>.</p>
<p>You can also ask for the top <em>n</em> minimum, for example:</p>
<pre><code class="lang-csharp">// We explicitly discard the first three arguments
var minValue = image.Max(out _, out _, out _, out var xPos, out var yPos);
</code></pre>
<p>Now <code>xPos</code> and <code>yPos</code> will be 10-element arrays.</p>
<p>Because operations are member functions and return the result image, you can
chain them. For example, you can write:</p>
<pre><code class="lang-csharp">var resultImage = image.Real().Cos();
</code></pre>
<p>to calculate the cosine of the real part of a complex image. There is
also a full set of arithmetic operator overloads, see below.</p>
<p>If an operation takes several input images, you can use a constant for all but
one of them and the wrapper will expand the constant to an image for you. For
example, <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Ifthenelse_"><code>Ifthenelse</code></a> uses a condition image to pick
pixels between a then and an else image:</p>
<pre><code class="lang-csharp">var resultImage = conditionImage.Ifthenelse(thenImage, elseImage);
</code></pre>
<p>You can use a constant instead of either the then or the else parts and it
will be expanded to an image for you. If you use a constant for both then and
else, it will be expanded to match the condition image. For example:</p>
<pre><code class="lang-csharp">var resultImage = conditionImage.Ifthenelse(new[] {0, 255, 0}, new[] {255, 0, 0});
</code></pre>
<p>Will make an image where true pixels are green and false pixels are red.</p>
<p>This is useful for <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Bandjoin_"><code>Bandjoin</code></a>, the thing to join two or more
images up bandwise. You can write:</p>
<pre><code class="lang-csharp">var rgba = rgb.Bandjoin(255);
</code></pre>
<p>to append a constant 255 band to an image, perhaps to add an alpha channel. Of
course you can also write:</p>
<pre><code class="lang-csharp">var resultImage = image1.Bandjoin(image2);
resultImage = image1.Bandjoin(new[] {image2, image3});
resultImage = image1.Bandjoin(new[] {image2, 255});
</code></pre>
<p>and so on.</p>
<h2 id="logging-and-warnings">Logging and warnings</h2>
<p>NetVips can log warnings and debug messages from libvips. Some warnings are important,
for example truncated files, and you might want to see them.</p>
<p>Add these lines somewhere near the start of your program:</p>
<pre><code class="lang-csharp">_handlerId = Log.SetLogHandler(&quot;VIPS&quot;, Enums.LogLevelFlags.Warning, (domain, level, message) =&gt;
{
    Console.WriteLine(&quot;Domain: '{0}' Level: {1}&quot;, domain, level);
    Console.WriteLine(&quot;Message: {0}&quot;, message);
});
</code></pre>
<p>Make sure to remove the log handler, if you do not need it anymore:</p>
<pre><code class="lang-csharp">Log.RemoveLogHandler(&quot;VIPS&quot;, _handlerId);
</code></pre>
<h2 id="automatic-documentation">Automatic documentation</h2>
<p>These API docs are generated automatically by DocFX. It generates API reference documentation
from triple-slash comments in our source code.</p>
<h2 id="generated-methods">Generated methods</h2>
<p>The <code>Image.Generated.cs</code> file where all libvips operations are located
is generated automatically by <a class="xref" href="../api/NetVips.Operation.html#NetVips_Operation_GenerateImageClass_"><code>Operation.GenerateImageClass</code></a>.
It examines libvips and writes the XML documentation and the corresponding code of each operation.</p>
<p>Use the C API docs for more detail:</p>
<p><a href="https://libvips.github.io/libvips/API/current">https://libvips.github.io/libvips/API/current</a></p>
<h2 id="exceptions">Exceptions</h2>
<p>The wrapper spots errors from vips operations and raises the <a class="xref" href="../api/NetVips.VipsException.html"><code>VipsException</code></a>.
You can catch it in the usual way.</p>
<h2 id="enums">Enums</h2>
<p>The libvips enums, such as <code>VipsBandFormat</code>, appear in NetVips as strings constants
like <code>&quot;uchar&quot;</code>. They are documented as a set of classes for convenience, see
<a class="xref" href="../api/NetVips.Enums.Access.html"><code>Enums.Access</code></a>, for example.</p>
<h2 id="draw-operations">Draw operations</h2>
<p>Paint operations like <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_DrawCircle_"><code>DrawCircle</code></a> and
<a class="xref" href="../api/NetVips.Image.html#NetVips_Image_DrawLine_"><code>DrawLine</code></a> modify their input image. This makes them
hard to use with the rest of libvips: you need to be very careful about
the order in which operations execute or you can get nasty crashes.</p>
<p>The wrapper spots operations of this type and makes a private copy of the
image in memory before calling the operation. This stops crashes, but it does
make it inefficient. If you draw 100 lines on an image, for example, you'll
copy the image 100 times. The wrapper does make sure that memory is recycled
where possible, so you won't have 100 copies in memory.</p>
<p>If you want to avoid the copies, you'll need to call drawing operations
yourself.</p>
<h2 id="overloads">Overloads</h2>
<p>The wrapper defines the usual set of arithmetic, boolean and relational
overloads on image. You can mix images, constants and lists of constants
freely. For example, you can write:</p>
<pre><code class="lang-csharp">var resultImage = ((image * new[] {1, 2, 3}).Abs() &lt; 128) | 4;
</code></pre>
<h2 id="expansions">Expansions</h2>
<p>Some vips operators take an enum to select an action, for example
<a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Math_"><code>Math</code></a> can be used to calculate sine of every pixel
like this:</p>
<pre><code class="lang-csharp">var resultImage = image.Math(&quot;sin&quot;);
</code></pre>
<p>This is annoying, so the wrapper expands all these enums into separate members
named after the enum value. So you can also write:</p>
<pre><code class="lang-csharp">var resultImage = image.Sin();
</code></pre>
<h2 id="convenience-functions">Convenience functions</h2>
<p>The wrapper defines a few extra useful utility functions:
<a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Bandsplit_"><code>Bandsplit</code></a>,
<a class="xref" href="../api/NetVips.Image.html#NetVips_Image_MaxPos_"><code>MaxPos</code></a>,
<a class="xref" href="../api/NetVips.Image.html#NetVips_Image_MinPos_"><code>MinPos</code></a>,
and <a class="xref" href="../api/NetVips.Image.html#NetVips_Image_Median_"><code>Median</code></a>.</p>
</article>
          </div>
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/kleisauke/net-vips/blob/master/documentation/tutorial/getting_started.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>  </body>
</html>
